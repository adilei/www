declare module 'adaptivecards-designer/containers/host-container' {
	import * as Adaptive from "adaptivecards";
	export abstract class HostContainer {
	    private _cardHost;
	    readonly name: string;
	    readonly styleSheet: string;
	    constructor(name: string, styleSheet: string);
	    abstract renderTo(hostElement: HTMLElement): any;
	    initialize(): void;
	    getBackgroundColor(): string;
	    parseElement(element: Adaptive.CardElement, json: any): void;
	    anchorClicked(element: Adaptive.CardElement, anchor: HTMLAnchorElement): boolean;
	    getHostConfig(): Adaptive.HostConfig;
	    supportsActionBar: boolean;
	    readonly cardHost: HTMLElement;
	    readonly isFixedHeight: boolean;
	}

}
declare module 'adaptivecards-designer/containers/default/default-container' {
	import { HostContainer } from 'adaptivecards-designer/containers/host-container';
	export class DefaultContainer extends HostContainer {
	    renderTo(hostElement: HTMLElement): void;
	}

}
declare module 'adaptivecards-designer/containers/bf-image/bf-image-container' {
	import * as Adaptive from "adaptivecards";
	import { HostContainer } from 'adaptivecards-designer/containers/host-container';
	export class BotFrameworkContainer extends HostContainer {
	    renderTo(hostElement: HTMLElement): void;
	    getHostConfig(): Adaptive.HostConfig;
	}

}
declare module 'adaptivecards-designer/containers/cortana-classic/cortana-classic-container' {
	import * as Adaptive from "adaptivecards";
	import { HostContainer } from 'adaptivecards-designer/containers/host-container';
	export class CortanaClassicContainer extends HostContainer {
	    renderTo(hostElement: HTMLElement): void;
	    getHostConfig(): Adaptive.HostConfig;
	}

}
declare module 'adaptivecards-designer/containers/cortana/cortana-container' {
	import * as Adaptive from "adaptivecards";
	import { HostContainer } from 'adaptivecards-designer/containers/host-container'; abstract class BaseCortanaContainer extends HostContainer {
	    renderTo(hostElement: HTMLElement): void;
	}
	export class LightCortanaContainer extends BaseCortanaContainer {
	    getHostConfig(): Adaptive.HostConfig;
	}
	export class DarkCortanaContainer extends BaseCortanaContainer {
	    getBackgroundColor(): string;
	    getHostConfig(): Adaptive.HostConfig;
	}
	export {};

}
declare module 'adaptivecards-designer/containers/notifications/toast-container' {
	import * as Adaptive from "adaptivecards";
	import { HostContainer } from 'adaptivecards-designer/containers/host-container';
	export class ToastContainer extends HostContainer {
	    renderTo(hostElement: HTMLElement): void;
	    getHostConfig(): Adaptive.HostConfig;
	}

}
declare module 'adaptivecards-designer/containers/outlook/outlook-container' {
	import * as Adaptive from "adaptivecards";
	import { HostContainer } from 'adaptivecards-designer/containers/host-container';
	export class OutlookContainer extends HostContainer {
	    renderTo(hostElement: HTMLElement): void;
	    initialize(): void;
	    private parsePadding;
	    parseElement(element: Adaptive.CardElement, json: any): void;
	    anchorClicked(element: Adaptive.CardElement, anchor: HTMLAnchorElement): boolean;
	    getHostConfig(): Adaptive.HostConfig;
	}

}
declare module 'adaptivecards-designer/containers/skype/skype-container' {
	import * as Adaptive from "adaptivecards";
	import { HostContainer } from 'adaptivecards-designer/containers/host-container';
	export class SkypeContainer extends HostContainer {
	    renderTo(hostElement: HTMLElement): void;
	    getHostConfig(): Adaptive.HostConfig;
	}

}
declare module 'adaptivecards-designer/containers/teams/teams-container' {
	import * as Adaptive from "adaptivecards";
	import { HostContainer } from 'adaptivecards-designer/containers/host-container'; abstract class BaseTeamsContainer extends HostContainer {
	    renderTo(hostElement: HTMLElement): void;
	}
	export class LightTeamsContainer extends BaseTeamsContainer {
	    getHostConfig(): Adaptive.HostConfig;
	}
	export class DarkTeamsContainer extends BaseTeamsContainer {
	    getBackgroundColor(): string;
	    getHostConfig(): Adaptive.HostConfig;
	}
	export {};

}
declare module 'adaptivecards-designer/containers/timeline/timeline-container' {
	import * as Adaptive from "adaptivecards";
	import { HostContainer } from 'adaptivecards-designer/containers/host-container';
	export class TimelineContainer extends HostContainer {
	    initialize(): void;
	    renderTo(hostElement: HTMLElement): void;
	    getHostConfig(): Adaptive.HostConfig;
	    readonly isFixedHeight: boolean;
	}

}
declare module 'adaptivecards-designer/containers/webchat/webchat-container' {
	import * as Adaptive from "adaptivecards";
	import { HostContainer } from 'adaptivecards-designer/containers/host-container';
	export class WebChatContainer extends HostContainer {
	    renderTo(hostElement: HTMLElement): void;
	    getHostConfig(): Adaptive.HostConfig;
	}

}
declare module 'adaptivecards-designer/containers/index' {
	export * from 'adaptivecards-designer/containers/host-container';
	export * from 'adaptivecards-designer/containers/default/default-container';
	export * from 'adaptivecards-designer/containers/bf-image/bf-image-container';
	export * from 'adaptivecards-designer/containers/cortana-classic/cortana-classic-container';
	export * from 'adaptivecards-designer/containers/cortana/cortana-container';
	export * from 'adaptivecards-designer/containers/notifications/toast-container';
	export * from 'adaptivecards-designer/containers/outlook/outlook-container';
	export * from 'adaptivecards-designer/containers/skype/skype-container';
	export * from 'adaptivecards-designer/containers/teams/teams-container';
	export * from 'adaptivecards-designer/containers/timeline/timeline-container';
	export * from 'adaptivecards-designer/containers/webchat/webchat-container';

}
declare module 'adaptivecards-designer/strings' {
	export class Strings {
	    static readonly toolboxes: {
	        toolPalette: {
	            title: string;
	        };
	        cardEditor: {
	            title: string;
	        };
	        sampleDataEditor: {
	            title: string;
	        };
	        propertySheet: {
	            title: string;
	        };
	        cardStructure: {
	            title: string;
	        };
	        dataStructure: {
	            title: string;
	        };
	    };
	    static loadingEditor: string;
	}

}
declare module 'adaptivecards-designer/shared' {
	import * as Adaptive from "adaptivecards";
	export class GlobalSettings {
	    static enableDataBindingSupport: boolean;
	    static showDataStructureToolbox: boolean;
	    static showSampleDataEditorToolbox: boolean;
	    static showVersionPicker: boolean;
	}
	export type TargetVersion = Adaptive.Version | "*";
	export class Versions {
	    static readonly v1_0: Adaptive.Version;
	    static readonly v1_1: Adaptive.Version;
	    static readonly v1_2: Adaptive.Version;
	    static readonly latest: Adaptive.Version;
	    static readonly vNext: Adaptive.Version;
	}
	export var SupportedTargetVersions: Adaptive.Version[];
	export function isVersionLessOrEqual(version: TargetVersion, targetVersion: TargetVersion): boolean;

}
declare module 'adaptivecards-designer/miscellaneous' {
	import * as Adaptive from "adaptivecards";
	export interface IPoint {
	    x: number;
	    y: number;
	}
	export class Rect {
	    top: number;
	    right: number;
	    bottom: number;
	    left: number;
	    constructor(top?: number, right?: number, bottom?: number, left?: number);
	    union(otherRect: Rect): void;
	    isInside(point: IPoint): boolean;
	    readonly width: number;
	    readonly height: number;
	}
	export class Utils {
	    static isAbsoluteUrl(urlString: string): boolean;
	    static joinPaths(...args: string[]): string;
	}
	export var defaultHostConfig: Adaptive.HostConfig;

}
declare module 'adaptivecards-designer/draggable-element' {
	export const DRAG_THRESHOLD = 10;
	export abstract class DraggableElement {
	    private _renderedElement;
	    private _isPointerOver;
	    private _isPointerDown;
	    private _lastClickedPoint;
	    private _dragging;
	    private releasePointerCapture;
	    protected isPointerOver: boolean;
	    protected startDrag(): void;
	    protected pointerDown(e: PointerEvent): void;
	    protected pointerUp(e: PointerEvent): void;
	    protected pointerMove(e: PointerEvent): void;
	    protected click(e: MouseEvent): void;
	    protected doubleClick(e: MouseEvent): void;
	    protected internalUpdateCssStyles(): void;
	    protected internalUpdateLayout(): void;
	    protected getDragSourceElement(): HTMLElement;
	    protected abstract internalRender(): HTMLElement;
	    onStartDrag: (sender: DraggableElement) => void;
	    onEndDrag: (sender: DraggableElement) => void;
	    onClick: (sender: DraggableElement) => void;
	    onDoubleClick: (sender: DraggableElement) => void;
	    isDraggable(): boolean;
	    endDrag(): void;
	    updateLayout(): void;
	    render(): HTMLElement;
	    readonly renderedElement: HTMLElement;
	    dragging: boolean;
	}

}
declare module 'adaptivecards-designer/peer-command' {
	export class PeerCommand {
	    private _renderedElement;
	    protected internalRender(): HTMLElement;
	    name: string;
	    iconClass: string;
	    isPromotable: boolean;
	    execute: (command: PeerCommand, clickedElement: HTMLElement) => void;
	    constructor(init?: Partial<PeerCommand>);
	    render(): HTMLElement;
	    readonly renderedElement: HTMLElement;
	}

}
declare module 'adaptivecards-designer/base-tree-item' {
	import { DraggableElement } from 'adaptivecards-designer/draggable-element';
	export abstract class BaseTreeItem extends DraggableElement {
	    private static collapsedIconClass;
	    private static expandedIconClass;
	    private _isExpanded;
	    private _isSelected;
	    private _treeItemElement;
	    private _expandCollapseElement;
	    private _childContainerElement;
	    protected abstract getLabelText(): string;
	    protected click(e: MouseEvent): void;
	    protected getIconClass(): string;
	    protected getAdditionalText(): string;
	    protected getAdditionalTextClass(): string;
	    protected getIndentationLevelIncrement(): number;
	    protected getDragSourceElement(): HTMLElement;
	    protected selected(): void;
	    protected internalRender(): HTMLElement;
	    protected _level: number;
	    constructor();
	    abstract getChildCount(): number;
	    abstract getChildAt(index: number): BaseTreeItem;
	    updateLayout(): void;
	    expand(): void;
	    isDraggable(): boolean;
	    readonly level: number;
	    isSelected: boolean;
	}

}
declare module 'adaptivecards-designer/designer-peer-treeitem' {
	import { BaseTreeItem } from 'adaptivecards-designer/base-tree-item';
	import { DesignerPeer } from 'adaptivecards-designer/designer-peers';
	export class DesignerPeerTreeItem extends BaseTreeItem {
	    private computeLevel;
	    protected getIconClass(): string;
	    protected getLabelText(): string;
	    protected getAdditionalText(): string;
	    protected selected(): void;
	    readonly owner: DesignerPeer;
	    constructor(owner: DesignerPeer);
	    getChildCount(): number;
	    getChildAt(index: number): BaseTreeItem;
	    updateLayout(): void;
	}

}
declare module 'adaptivecards-designer/designer-peers' {
	import * as Adaptive from "adaptivecards";
	import { DraggableElement } from 'adaptivecards-designer/draggable-element';
	import { PeerCommand } from 'adaptivecards-designer/peer-command';
	import { CardDesignerSurface } from 'adaptivecards-designer/card-designer-surface';
	import { DesignerPeerTreeItem } from 'adaptivecards-designer/designer-peer-treeitem';
	import { Rect, IPoint } from 'adaptivecards-designer/miscellaneous';
	import { TargetVersion } from 'adaptivecards-designer/shared';
	export abstract class DesignerPeerInplaceEditor {
	    onClose: (applyChanges: boolean) => void;
	    abstract initialize(): any;
	    abstract applyChanges(): any;
	    abstract render(): HTMLElement;
	}
	export abstract class CardElementPeerInplaceEditor<TCardElement extends Adaptive.CardElement> extends DesignerPeerInplaceEditor {
	    readonly cardElement: TCardElement;
	    constructor(cardElement: TCardElement);
	}
	export class DesignerPeerRegistrationBase {
	    readonly category: string;
	    readonly iconClass: string;
	    constructor(category: string, iconClass?: string);
	}
	export class DesignerPeerRegistration<TSource, TPeer> extends DesignerPeerRegistrationBase {
	    readonly sourceType: TSource;
	    peerType: TPeer;
	    constructor(sourceType: TSource, peerType: TPeer, category: string, iconClass?: string);
	}
	export class PropertySheetCategory {
	    readonly name: string;
	    static readonly DefaultCategory = "__defaultCategory";
	    static readonly LayoutCategory = "Layout";
	    static readonly StyleCategory = "Style";
	    static readonly SelectionAction = "Selection action";
	    static readonly InlineAction = "Inline action";
	    private _entries;
	    constructor(name: string);
	    render(container: Adaptive.Container, context: PropertySheetContext, displayCategoryName: boolean): void;
	    add(...entries: PropertySheetEntry[]): void;
	    remove(...entries: PropertySheetEntry[]): void;
	    getEntryAt(index: number): PropertySheetEntry;
	    readonly length: number;
	}
	export class PropertySheet {
	    readonly displayCategoryNames: boolean;
	    private _categories;
	    constructor(displayCategoryNames?: boolean);
	    add(categoryName: string, ...entries: PropertySheetEntry[]): void;
	    remove(...entries: PropertySheetEntry[]): void;
	    render(container: Adaptive.Container, context: PropertySheetContext): void;
	}
	export abstract class DesignerPeer extends DraggableElement {
	    private _parent;
	    private _children;
	    private _isSelected;
	    private _inplaceEditorOverlay;
	    private _inplaceEditor;
	    private closeInplaceEditor;
	    private tryOpenInplaceEditor;
	    protected click(e: MouseEvent): void;
	    protected doubleClick(e: MouseEvent): void;
	    protected isContainer(): boolean;
	    protected getToolTip(): string;
	    protected internalAddCommands(commands: Array<PeerCommand>): void;
	    protected internalRender(): HTMLElement;
	    protected internalUpdateCssStyles(): void;
	    protected peerAdded(newPeer: DesignerPeer): void;
	    protected peerRemoved(peer: DesignerPeer): void;
	    protected internalUpdateLayout(): void;
	    protected createInplaceEditor(): DesignerPeerInplaceEditor;
	    protected internalGetTreeItemText(): string;
	    protected abstract internalRemove(): boolean;
	    readonly registration: DesignerPeerRegistrationBase;
	    readonly designerSurface: CardDesignerSurface;
	    readonly treeItem: DesignerPeerTreeItem;
	    onParentChanged: (sender: DesignerPeer) => void;
	    onSelectedChanged: (sender: DesignerPeer) => void;
	    onChanged: (sender: DesignerPeer, updatePropertySheet: boolean) => void;
	    onPeerRemoved: (sender: DesignerPeer) => void;
	    onPeerAdded: (sender: DesignerPeer, newPeer: DesignerPeer) => void;
	    abstract getCardObject(): Adaptive.CardObject;
	    constructor(parent: DesignerPeer, designerSurface: CardDesignerSurface, registration: DesignerPeerRegistrationBase);
	    abstract getBoundingRect(): Rect;
	    abstract getCardObjectBoundingRect(): Rect;
	    changed(updatePropertySheet: boolean): void;
	    getTreeItemText(): string;
	    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
	    canDrop(peer: DesignerPeer): boolean;
	    canBeRemoved(): boolean;
	    tryDrop(peer: DesignerPeer, insertionPoint: IPoint): boolean;
	    insertChild(peer: DesignerPeer, index?: number): void;
	    removeChild(peer: DesignerPeer): void;
	    getChildCount(): number;
	    getChildAt(index: number): DesignerPeer;
	    getCommands(promoteParentCommands?: boolean): Array<PeerCommand>;
	    remove(onlyFromCard: boolean, removeChildren: boolean): boolean;
	    addElementsToDesignerSurface(designerSurface: HTMLElement, processChildren?: boolean): void;
	    removeElementsFromDesignerSurface(processChildren?: boolean): void;
	    buildPropertySheetCard(targetVersion: TargetVersion): Adaptive.AdaptiveCard;
	    scrollIntoView(): void;
	    parent: DesignerPeer;
	    isSelected: boolean;
	}
	export class PropertySheetContext {
	    readonly targetVersion: TargetVersion;
	    readonly peer: CardObjectPeer;
	    private _target;
	    constructor(targetVersion: TargetVersion, peer: CardObjectPeer, target?: object);
	    readonly target: object;
	}
	export abstract class PropertySheetEntry {
	    readonly targetVersion: TargetVersion;
	    abstract render(context: PropertySheetContext): Adaptive.CardElement;
	    constructor(targetVersion: TargetVersion);
	}
	export class SubPropertySheetEntry {
	    readonly targetVersion: TargetVersion;
	    readonly target: object;
	    readonly propertySheet: PropertySheet;
	    render(context: PropertySheetContext): Adaptive.CardElement;
	    constructor(targetVersion: TargetVersion, target: object, propertySheet: PropertySheet);
	}
	export class CustomPropertySheetEntry extends PropertySheetEntry {
	    readonly targetVersion: TargetVersion;
	    readonly onRender: (context: PropertySheetContext) => Adaptive.CardElement;
	    render(context: PropertySheetContext): Adaptive.CardElement;
	    constructor(targetVersion: TargetVersion, onRender: (context: PropertySheetContext) => Adaptive.CardElement);
	}
	export abstract class SingleInputPropertyEditor extends PropertySheetEntry {
	    readonly targetVersion: TargetVersion;
	    readonly propertyName: string;
	    readonly label: string;
	    readonly causesPropertySheetRefresh: boolean;
	    protected abstract createInput(context: PropertySheetContext): Adaptive.Input;
	    protected getPropertyValue(context: PropertySheetContext): any;
	    protected setPropertyValue(context: PropertySheetContext, value: string): void;
	    render(context: PropertySheetContext): Adaptive.CardElement;
	    constructor(targetVersion: TargetVersion, propertyName: string, label: string, causesPropertySheetRefresh?: boolean);
	}
	export class StringPropertyEditor extends SingleInputPropertyEditor {
	    readonly targetVersion: TargetVersion;
	    readonly propertyName: string;
	    readonly label: string;
	    readonly isMultiline: boolean;
	    readonly causesPropertySheetRefresh: boolean;
	    protected createInput(context: PropertySheetContext): Adaptive.Input;
	    constructor(targetVersion: TargetVersion, propertyName: string, label: string, isMultiline?: boolean, causesPropertySheetRefresh?: boolean);
	}
	export class NumberPropertyEditor extends SingleInputPropertyEditor {
	    readonly targetVersion: TargetVersion;
	    readonly propertyName: string;
	    readonly label: string;
	    readonly defaultValue: number | undefined;
	    readonly causesPropertySheetRefresh: boolean;
	    protected setPropertyValue(context: PropertySheetContext, value: string): void;
	    protected createInput(context: PropertySheetContext): Adaptive.Input;
	    constructor(targetVersion: TargetVersion, propertyName: string, label: string, defaultValue?: number | undefined, causesPropertySheetRefresh?: boolean);
	}
	export class ObjectPropertyEditor extends StringPropertyEditor {
	    protected getPropertyValue(context: PropertySheetContext): any;
	    protected setPropertyValue(context: PropertySheetContext, value: string): void;
	}
	export class CustomCardObjectPropertyEditor extends StringPropertyEditor {
	    protected getPropertyValue(context: PropertySheetContext): any;
	    protected setPropertyValue(context: PropertySheetContext, value: string): void;
	}
	export class BooleanPropertyEditor extends SingleInputPropertyEditor {
	    protected getPropertyValue(context: PropertySheetContext): any;
	    protected setPropertyValue(context: PropertySheetContext, value: string): void;
	    protected createInput(context: PropertySheetContext): Adaptive.Input;
	}
	export interface IVersionedChoice {
	    targetVersion: TargetVersion;
	    name: string;
	    value: string;
	}
	export class ChoicePropertyEditor extends SingleInputPropertyEditor {
	    readonly targetVersion: TargetVersion;
	    readonly propertyName: string;
	    readonly label: string;
	    readonly choices: IVersionedChoice[];
	    readonly causesPropertySheetRefresh: boolean;
	    protected createInput(context: PropertySheetContext): Adaptive.Input;
	    constructor(targetVersion: TargetVersion, propertyName: string, label: string, choices: IVersionedChoice[], causesPropertySheetRefresh?: boolean);
	}
	export class ContainerStylePropertyEditor extends ChoicePropertyEditor {
	    readonly targetVersion: TargetVersion;
	    readonly propertyName: string;
	    readonly label: string;
	    protected getPropertyValue(context: PropertySheetContext): any;
	    protected setPropertyValue(context: PropertySheetContext, value: string): void;
	    constructor(targetVersion: TargetVersion, propertyName: string, label: string);
	}
	export class ColumnWidthPropertyEditor extends ChoicePropertyEditor {
	    protected getPropertyValue(context: PropertySheetContext): any;
	    protected setPropertyValue(context: PropertySheetContext, value: string): void;
	}
	export class HeightPropertyEditor extends ChoicePropertyEditor {
	    protected setPropertyValue(context: PropertySheetContext, value: string): void;
	}
	export class SizeAndUnitPropertyEditor extends NumberPropertyEditor {
	    readonly targetVersion: TargetVersion;
	    readonly propertyName: string;
	    readonly label: string;
	    readonly sizeUnit: Adaptive.SizeUnit;
	    readonly defaultValue: number | undefined;
	    readonly causesPropertySheetRefresh: boolean;
	    protected getPropertyValue(context: PropertySheetContext): any;
	    protected setPropertyValue(context: PropertySheetContext, value: string): void;
	    constructor(targetVersion: TargetVersion, propertyName: string, label: string, sizeUnit: Adaptive.SizeUnit, defaultValue?: number | undefined, causesPropertySheetRefresh?: boolean);
	}
	export class ActionPropertyEditor extends SingleInputPropertyEditor {
	    readonly targetVersion: TargetVersion;
	    readonly propertyName: string;
	    readonly label: string;
	    readonly forbiddenActionTypes: string[];
	    readonly causesPropertySheetRefresh: boolean;
	    protected getPropertyValue(context: PropertySheetContext): any;
	    protected setPropertyValue(context: PropertySheetContext, value: string): void;
	    protected createInput(context: PropertySheetContext): Adaptive.Input;
	    constructor(targetVersion: TargetVersion, propertyName: string, label: string, forbiddenActionTypes?: string[], causesPropertySheetRefresh?: boolean);
	}
	export class CompoundPropertyEditor extends PropertySheetEntry {
	    readonly targetVersion: TargetVersion;
	    readonly propertyName: string;
	    readonly entries: PropertySheetEntry[];
	    render(context: PropertySheetContext): Adaptive.CardElement;
	    constructor(targetVersion: TargetVersion, propertyName: string, entries?: PropertySheetEntry[]);
	}
	export class EnumPropertyEditor extends SingleInputPropertyEditor {
	    readonly targetVersion: TargetVersion;
	    readonly propertyName: string;
	    readonly label: string;
	    readonly enumType: {
	        [s: number]: string;
	    };
	    readonly causesPropertySheetRefresh: boolean;
	    protected setPropertyValue(context: PropertySheetContext, value: string): void;
	    protected createInput(context: PropertySheetContext): Adaptive.Input;
	    constructor(targetVersion: TargetVersion, propertyName: string, label: string, enumType: {
	        [s: number]: string;
	    }, causesPropertySheetRefresh?: boolean);
	} class NameValuePairPropertyEditor extends PropertySheetEntry {
	    readonly targetVersion: TargetVersion;
	    readonly collectionPropertyName: string;
	    readonly namePropertyName: string;
	    readonly valuePropertyName: string;
	    readonly createCollectionItem: (name: string, value: string) => any;
	    readonly namePropertyLabel: string;
	    readonly valuePropertyLabel: string;
	    readonly addButtonTitle: string;
	    readonly messageIfEmpty: string;
	    private collectionChanged;
	    render(context: PropertySheetContext): Adaptive.CardElement;
	    constructor(targetVersion: TargetVersion, collectionPropertyName: string, namePropertyName: string, valuePropertyName: string, createCollectionItem: (name: string, value: string) => any, namePropertyLabel?: string, valuePropertyLabel?: string, addButtonTitle?: string, messageIfEmpty?: string);
	}
	export abstract class CardObjectPeer extends DesignerPeer {
	    static readonly idProperty: StringPropertyEditor;
	}
	export class ActionPeer extends CardObjectPeer {
	    static readonly titleProperty: StringPropertyEditor;
	    static readonly styleProperty: ChoicePropertyEditor;
	    static readonly iconUrlProperty: StringPropertyEditor;
	    protected _action: Adaptive.Action;
	    protected doubleClick(e: MouseEvent): void;
	    protected internalRemove(): boolean;
	    constructor(parent: DesignerPeer, designerSurface: CardDesignerSurface, registration: DesignerPeerRegistrationBase, action: Adaptive.Action);
	    protected internalGetTreeItemText(): string;
	    getCardObject(): Adaptive.CardObject;
	    isDraggable(): boolean;
	    getBoundingRect(): Rect;
	    getCardObjectBoundingRect(): Rect;
	    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
	    readonly action: Adaptive.Action;
	}
	export abstract class TypedActionPeer<TAction extends Adaptive.Action> extends ActionPeer {
	    constructor(parent: DesignerPeer, designerSurface: CardDesignerSurface, registration: DesignerPeerRegistrationBase, action: TAction);
	    readonly action: TAction;
	}
	export class HttpActionPeer extends TypedActionPeer<Adaptive.HttpAction> {
	    static readonly ignoreInputValidationProperty: BooleanPropertyEditor;
	    static readonly methodProperty: ChoicePropertyEditor;
	    static readonly urlProperty: StringPropertyEditor;
	    static readonly bodyProperty: StringPropertyEditor;
	    static readonly headersProperty: NameValuePairPropertyEditor;
	    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
	}
	export class SubmitActionPeer extends TypedActionPeer<Adaptive.SubmitAction> {
	    static readonly ignoreInputValidationProperty: BooleanPropertyEditor;
	    static readonly dataProperty: ObjectPropertyEditor;
	    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
	}
	export class OpenUrlActionPeer extends TypedActionPeer<Adaptive.OpenUrlAction> {
	    static readonly urlProperty: StringPropertyEditor;
	    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
	}
	export class ShowCardActionPeer extends TypedActionPeer<Adaptive.ShowCardAction> {
	    protected getToolTip(): string;
	}
	export class ToggleVisibilityActionPeer extends TypedActionPeer<Adaptive.ToggleVisibilityAction> {
	}
	export class CardElementPeer extends CardObjectPeer {
	    static readonly dataContextProperty: CustomCardObjectPropertyEditor;
	    static readonly whenProperty: CustomCardObjectPropertyEditor;
	    static readonly idProperty: StringPropertyEditor;
	    static readonly isVisibleProperty: BooleanPropertyEditor;
	    static readonly spacingProperty: EnumPropertyEditor;
	    static readonly separatorProperty: BooleanPropertyEditor;
	    static readonly horizontalAlignmentProperty: EnumPropertyEditor;
	    static readonly heightProperty: HeightPropertyEditor;
	    protected _cardElement: Adaptive.CardElement;
	    protected insertElementAfter(newElement: Adaptive.CardElement): void;
	    protected internalRemove(): boolean;
	    protected internalUpdateCssStyles(): void;
	    constructor(parent: DesignerPeer, designerSurface: CardDesignerSurface, registration: DesignerPeerRegistrationBase, cardElement: Adaptive.CardElement);
	    getTreeItemText(): string;
	    getCardObject(): Adaptive.CardObject;
	    initializeCardElement(): void;
	    canDrop(peer: DesignerPeer): boolean;
	    tryDrop(peer: DesignerPeer, insertionPoint: IPoint): boolean;
	    getBoundingRect(): Rect;
	    getCardObjectBoundingRect(): Rect;
	    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
	    readonly cardElement: Adaptive.CardElement;
	}
	export abstract class TypedCardElementPeer<TCardElement extends Adaptive.CardElement> extends CardElementPeer {
	    constructor(parent: DesignerPeer, designerSurface: CardDesignerSurface, registration: DesignerPeerRegistrationBase, cardElement: TCardElement);
	    readonly cardElement: TCardElement;
	}
	export class AdaptiveCardPeer extends TypedCardElementPeer<Adaptive.AdaptiveCard> {
	    static readonly langProperty: StringPropertyEditor;
	    static readonly fallbackTextProperty: StringPropertyEditor;
	    static readonly speakProperty: StringPropertyEditor;
	    protected addAction(action: Adaptive.Action): void;
	    protected internalRemove(): boolean;
	    protected internalAddCommands(commands: Array<PeerCommand>): void;
	    isDraggable(): boolean;
	    canBeRemoved(): boolean;
	    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
	}
	export class ColumnPeer extends TypedCardElementPeer<Adaptive.Column> {
	    private static readonly pixelWidthProperty;
	    private static readonly weightProperty;
	    static readonly widthProperty: ColumnWidthPropertyEditor;
	    protected isContainer(): boolean;
	    protected internalGetTreeItemText(): string;
	    isDraggable(): boolean;
	    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
	}
	export class ColumnSetPeer extends TypedCardElementPeer<Adaptive.ColumnSet> {
	    protected isContainer(): boolean;
	    protected internalAddCommands(commands: Array<PeerCommand>): void;
	    protected internalGetTreeItemText(): string;
	    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
	    canDrop(peer: DesignerPeer): boolean;
	}
	export class ContainerPeer extends TypedCardElementPeer<Adaptive.Container> {
	    static readonly selectActionProperty: ActionPropertyEditor;
	    static readonly minHeightProperty: NumberPropertyEditor;
	    static readonly verticalContentAlignmentProperty: EnumPropertyEditor;
	    static readonly styleProperty: ContainerStylePropertyEditor;
	    static readonly bleedProperty: BooleanPropertyEditor;
	    static readonly backgroundImageProperty: CompoundPropertyEditor;
	    protected isContainer(): boolean;
	    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
	}
	export class ActionSetPeer extends TypedCardElementPeer<Adaptive.AdaptiveCard> {
	    protected addAction(action: Adaptive.Action): void;
	    protected internalAddCommands(commands: Array<PeerCommand>): void;
	}
	export class ImageSetPeer extends TypedCardElementPeer<Adaptive.ImageSet> {
	    static readonly ImageSizeProperty: EnumPropertyEditor;
	    protected internalAddCommands(commands: Array<PeerCommand>): void;
	    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
	}
	export class ImagePeer extends TypedCardElementPeer<Adaptive.Image> {
	    static readonly urlProperty: StringPropertyEditor;
	    static readonly altTextProperty: StringPropertyEditor;
	    static readonly sizeProperty: EnumPropertyEditor;
	    static readonly pixelWidthProperty: NumberPropertyEditor;
	    static readonly pixelHeightProperty: NumberPropertyEditor;
	    static readonly styleProperty: EnumPropertyEditor;
	    static readonly backgroundColorProperty: StringPropertyEditor;
	    private readonly isParentImageSet;
	    isDraggable(): boolean;
	    getBoundingRect(): Rect;
	    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
	}
	export class MediaPeer extends TypedCardElementPeer<Adaptive.Media> {
	    static readonly altTextProperty: StringPropertyEditor;
	    static readonly posterUrlProperty: StringPropertyEditor;
	    static readonly sourcesProperty: NameValuePairPropertyEditor;
	    protected internalGetTreeItemText(): string;
	    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
	}
	export class FactSetPeer extends TypedCardElementPeer<Adaptive.FactSet> {
	    static readonly factsProperty: NameValuePairPropertyEditor;
	    protected internalGetTreeItemText(): string;
	    initializeCardElement(): void;
	    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
	}
	export abstract class InputPeer<TInput extends Adaptive.Input> extends TypedCardElementPeer<TInput> {
	    static readonly defaultValueProperty: StringPropertyEditor;
	    static readonly validationProperty: CompoundPropertyEditor;
	    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
	}
	export class TextInputPeer extends InputPeer<Adaptive.TextInput> {
	    static readonly placeholderProperty: StringPropertyEditor;
	    static readonly isMultilineProperty: BooleanPropertyEditor;
	    static readonly styleProperty: EnumPropertyEditor;
	    static readonly maxLengthProperty: NumberPropertyEditor;
	    static readonly inlineActionProperty: ActionPropertyEditor;
	    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
	    initializeCardElement(): void;
	}
	export class NumberInputPeer extends InputPeer<Adaptive.NumberInput> {
	    static readonly placeholderProperty: StringPropertyEditor;
	    static readonly minProperty: NumberPropertyEditor;
	    static readonly maxProperty: NumberPropertyEditor;
	    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
	    initializeCardElement(): void;
	}
	export class DateInputPeer extends InputPeer<Adaptive.DateInput> {
	    static readonly minProperty: StringPropertyEditor;
	    static readonly maxProperty: StringPropertyEditor;
	    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
	}
	export class TimeInputPeer extends InputPeer<Adaptive.TimeInput> {
	    static readonly minProperty: StringPropertyEditor;
	    static readonly maxProperty: StringPropertyEditor;
	    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
	}
	export class ToggleInputPeer extends InputPeer<Adaptive.ToggleInput> {
	    static readonly titleProperty: StringPropertyEditor;
	    static readonly valueOnProperty: StringPropertyEditor;
	    static readonly valueOffProperty: StringPropertyEditor;
	    static readonly wrapProperty: BooleanPropertyEditor;
	    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
	    initializeCardElement(): void;
	}
	export class ChoiceSetInputPeer extends InputPeer<Adaptive.ChoiceSetInput> {
	    static readonly placeholderProperty: StringPropertyEditor;
	    static readonly isMultiselectProperty: BooleanPropertyEditor;
	    static readonly isCompactProperty: BooleanPropertyEditor;
	    static readonly wrapProperty: BooleanPropertyEditor;
	    static readonly choicesProperty: NameValuePairPropertyEditor;
	    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
	    initializeCardElement(): void;
	}
	export class TextBlockPeer extends TypedCardElementPeer<Adaptive.TextBlock> {
	    static readonly textProperty: StringPropertyEditor;
	    static readonly wrapProperty: BooleanPropertyEditor;
	    static readonly maxLinesProperty: NumberPropertyEditor;
	    static readonly fontTypeProperty: EnumPropertyEditor;
	    static readonly sizeProperty: EnumPropertyEditor;
	    static readonly weightProperty: EnumPropertyEditor;
	    static readonly colorProperty: EnumPropertyEditor;
	    static readonly subtleProperty: BooleanPropertyEditor;
	    protected createInplaceEditor(): DesignerPeerInplaceEditor;
	    protected internalGetTreeItemText(): string;
	    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
	    getToolTip(): string;
	    initializeCardElement(): void;
	}
	export class RichTextBlockPeer extends TypedCardElementPeer<Adaptive.RichTextBlock> {
	    protected internalGetTreeItemText(): string;
	    populatePropertySheet(propertySheet: PropertySheet, defaultCategory?: string): void;
	    initializeCardElement(): void;
	}
	export {};

}
declare module 'adaptivecards-designer/card-designer-surface' {
	import * as Adaptive from "adaptivecards";
	import { IPoint } from 'adaptivecards-designer/miscellaneous';
	import * as DesignerPeers from 'adaptivecards-designer/designer-peers';
	export type CardElementType = {
	    new (): Adaptive.CardElement;
	};
	export type ActionType = {
	    new (): Adaptive.Action;
	};
	export type CardElementPeerType = {
	    new (parent: DesignerPeers.DesignerPeer, designerSurface: CardDesignerSurface, registration: DesignerPeers.DesignerPeerRegistrationBase, cardElement: Adaptive.CardElement): DesignerPeers.CardElementPeer;
	};
	export type ActionPeerType = {
	    new (parent: DesignerPeers.DesignerPeer, designerSurface: CardDesignerSurface, registration: DesignerPeers.DesignerPeerRegistrationBase, action: Adaptive.Action): DesignerPeers.ActionPeer;
	};
	export abstract class DesignerPeerRegistry<TSource, TPeer> {
	    protected _items: Array<DesignerPeers.DesignerPeerRegistration<TSource, TPeer>>;
	    readonly defaultRegistration: DesignerPeers.DesignerPeerRegistrationBase;
	    constructor();
	    abstract reset(): any;
	    clear(): void;
	    findTypeRegistration(sourceType: TSource): DesignerPeers.DesignerPeerRegistration<TSource, TPeer>;
	    registerPeer(sourceType: TSource, peerType: TPeer, category: string, iconClass?: string): void;
	    unregisterPeer(sourceType: TSource): void;
	}
	export class CardElementPeerRegistry extends DesignerPeerRegistry<CardElementType, CardElementPeerType> {
	    reset(): void;
	    createPeerInstance(designerSurface: CardDesignerSurface, parent: DesignerPeers.DesignerPeer, cardElement: Adaptive.CardElement): DesignerPeers.CardElementPeer;
	}
	export class ActionPeerRegistry extends DesignerPeerRegistry<ActionType, ActionPeerType> {
	    reset(): void;
	    createPeerInstance(designerSurface: CardDesignerSurface, parent: DesignerPeers.DesignerPeer, action: Adaptive.Action): DesignerPeers.ActionPeer;
	}
	export class CardDesignerSurface {
	    static readonly cardElementPeerRegistry: CardElementPeerRegistry;
	    static readonly actionPeerRegistry: ActionPeerRegistry;
	    private _updateCount;
	    private _card;
	    private _allPeers;
	    private _rootPeer;
	    private _cardHost;
	    private _designerSurface;
	    private _selectedPeer;
	    private _draggedPeer;
	    private _dropTarget;
	    private _dragHandle;
	    private _removeCommandElement;
	    private _peerCommandsHostElement;
	    private _lastParseErrors;
	    private _isPreviewMode;
	    private _sampleData;
	    private updatePeerCommandsLayout;
	    private setSelectedPeer;
	    private peerChanged;
	    private peerRemoved;
	    private renderCard;
	    private addPeer;
	    private internalFindDropTarget;
	    private findCardElementPeer;
	    private findActionPeer;
	    private inlineCardExpanded;
	    private draggedPeer;
	    readonly parentElement: HTMLElement;
	    constructor(parentElement: HTMLElement);
	    onCardValidated: (parseErrors: Array<Adaptive.IValidationError>, validationResults: Adaptive.ValidationResults) => void;
	    onSelectedPeerChanged: (peer: DesignerPeers.DesignerPeer) => void;
	    onLayoutUpdated: (isFullRefresh: boolean) => void;
	    fixedHeightCard: boolean;
	    getDesignerSurfaceOffset(): IPoint;
	    findDropTarget(pointerPosition: IPoint, peer: DesignerPeers.DesignerPeer): DesignerPeers.DesignerPeer;
	    findPeer(cardObject: Adaptive.CardObject): DesignerPeers.DesignerPeer;
	    beginUpdate(): void;
	    endUpdate(renderCard: boolean): void;
	    render(): void;
	    setCardPayloadAsObject(payload: object): void;
	    setCardPayloadAsString(payload: string): void;
	    updateLayout(isFullRefresh?: boolean): void;
	    removeSelected(): void;
	    startDrag(peer: DesignerPeers.DesignerPeer): void;
	    endDrag(): void;
	    tryDrop(pointerPosition: IPoint, peer: DesignerPeers.DesignerPeer): boolean;
	    isPointerOver(x: number, y: number): boolean;
	    pageToClientCoordinates(x: number, y: number): IPoint;
	    readonly rootPeer: DesignerPeers.DesignerPeer;
	    readonly selectedPeer: DesignerPeers.DesignerPeer;
	    card: Adaptive.AdaptiveCard;
	    isPreviewMode: boolean;
	    sampleData: any;
	}

}
declare module 'adaptivecards-designer/constants' {
	export const otherTestPayload: string;
	export const defaultPayload: string;
	export const defaultTemplatePayload: string;
	export const defaultDataPayload: string;

}
declare module 'adaptivecards-designer/downloader' {
	export class Downloader {
	    readonly url: string;
	    private _data;
	    private error;
	    private success;
	    onError: (sender: Downloader) => void;
	    onSuccess: (sender: Downloader) => void;
	    constructor(url: string);
	    download(): void;
	    readonly data: string;
	}

}
declare module 'adaptivecards-designer/catalogue' {
	export class CatalogueEntry {
	    readonly displayName: string;
	    readonly cardPayloadUrl: string;
	    private _cardPayload;
	    private _cardPayloadDownloaded;
	    private _sampleData;
	    private _sampleDataDownloaded;
	    private downloadCompleted;
	    sampleDataUrl?: string;
	    onDownloaded: (sender: CatalogueEntry) => void;
	    constructor(displayName: string, cardPayloadUrl: string, sampleDataUrl?: string);
	    download(): void;
	    readonly cardPayload: string;
	    readonly sampleData: string;
	}
	export function parseCatalogue(input: any): CatalogueEntry[];

}
declare module 'adaptivecards-designer/dialog' {
	export abstract class Dialog {
	    private _overlayElement;
	    private _isOpen;
	    protected abstract renderContent(): HTMLElement;
	    onClose: (sender: Dialog) => void;
	    title: string;
	    width: string;
	    height: string;
	    open(): void;
	    close(): void;
	}

}
declare module 'adaptivecards-designer/sample-picker-dialog' {
	import { CatalogueEntry } from 'adaptivecards-designer/catalogue';
	import { Dialog } from 'adaptivecards-designer/dialog';
	export class SamplePickerDialog extends Dialog {
	    private _renderedElement;
	    private _selectedSample;
	    private renderMessage;
	    private renderCatalogue;
	    protected renderContent(): HTMLElement;
	    catalogueUrl: string;
	    readonly selectedSample: CatalogueEntry;
	}

}
declare module 'adaptivecards-designer/adaptive-card-schema' {
	export const adaptiveCardSchema: {
	    "$schema": string;
	    "id": string;
	    "type": string;
	    "title": string;
	    "additionalProperties": boolean;
	    "allOf": {
	        "$ref": string;
	    }[];
	    "properties": {
	        "version": {
	            "type": string;
	            "description": string;
	        };
	        "minVersion": {
	            "type": string;
	            "description": string;
	        };
	        "fallbackText": {
	            "type": string;
	            "description": string;
	        };
	        "speak": {
	            "type": string;
	            "description": string;
	        };
	    };
	    "required": string[];
	    "definitions": {
	        "Action": {
	            "anyOf": {
	                "$ref": string;
	            }[];
	        };
	        "Action.OpenUrl": {
	            "additionalProperties": boolean;
	            "description": string;
	            "properties": {
	                "title": {
	                    "type": string;
	                    "description": string;
	                };
	                "type": {
	                    "type": string;
	                    "description": string;
	                    "enum": string[];
	                };
	                "url": {
	                    "type": string;
	                    "description": string;
	                };
	            };
	            "required": string[];
	            "type": string;
	        };
	        "Action.ShowCard": {
	            "type": string;
	            "additionalProperties": boolean;
	            "description": string;
	            "properties": {
	                "type": {
	                    "type": string;
	                    "description": string;
	                    "enum": string[];
	                };
	                "title": {
	                    "type": string;
	                    "description": string;
	                };
	                "card": {
	                    "$ref": string;
	                };
	            };
	            "required": string[];
	        };
	        "Action.Submit": {
	            "type": string;
	            "additionalProperties": boolean;
	            "description": string;
	            "properties": {
	                "type": {
	                    "type": string;
	                    "description": string;
	                    "enum": string[];
	                };
	                "title": {
	                    "type": string;
	                    "description": string;
	                };
	                "data": {
	                    "type": string[];
	                    "description": string;
	                };
	            };
	            "required": string[];
	        };
	        "Actions": {
	            "additionalItems": boolean;
	            "items": {
	                "$ref": string;
	            };
	            "type": string;
	        };
	        "AdaptiveCard": {
	            "additionalProperties": boolean;
	            "type": string;
	            "description": string;
	            "properties": {
	                "type": {
	                    "type": string;
	                    "description": string;
	                    "enum": string[];
	                };
	                "actions": {
	                    "description": string;
	                    "$ref": string;
	                };
	                "body": {
	                    "description": string;
	                    "$ref": string;
	                };
	            };
	            "required": string[];
	        };
	        "CardElement": {
	            "additionalProperties": boolean;
	            "properties": {
	                "type": {
	                    "type": string;
	                };
	                "id": {
	                    "type": string;
	                    "description": string;
	                };
	                "spacing": {
	                    "$ref": string;
	                };
	                "separator": {
	                    "type": string;
	                    "description": string;
	                    "default": boolean;
	                };
	            };
	            "required": string[];
	        };
	        "CardElements": {
	            "type": string;
	            "additionalItems": boolean;
	            "items": {
	                "anyOf": {
	                    "$ref": string;
	                }[];
	            }[];
	        };
	        "Input.Choice": {
	            "type": string;
	            "description": string;
	            "additionalProperties": boolean;
	            "properties": {
	                "type": {
	                    "type": string;
	                    "enum": string[];
	                };
	                "title": {
	                    "type": string;
	                    "description": string;
	                };
	                "value": {
	                    "type": string;
	                    "description": string;
	                };
	            };
	            "required": string[];
	        };
	        "ChoiceInputStyle": {
	            "type": string;
	            "description": string;
	            "enum": string[];
	        };
	        "Column": {
	            "additionalProperties": boolean;
	            "type": string;
	            "description": string;
	            "allOf": {
	                "$ref": string;
	            }[];
	            "properties": {
	                "items": {
	                    "description": string;
	                    "$ref": string;
	                };
	                "selectAction": {
	                    "description": string;
	                    "$ref": string;
	                };
	                "width": {
	                    "type": string[];
	                    "description": string;
	                };
	                "type": {
	                    "type": string;
	                    "description": string;
	                    "enum": string[];
	                };
	            };
	            "required": string[];
	        };
	        "ColumnSet": {
	            "additionalProperties": boolean;
	            "type": string;
	            "description": string;
	            "allOf": {
	                "$ref": string;
	            }[];
	            "properties": {
	                "columns": {
	                    "type": string;
	                    "description": string;
	                    "items": {
	                        "$ref": string;
	                    };
	                };
	                "selectAction": {
	                    "$ref": string;
	                    "description": string;
	                };
	                "type": {
	                    "type": string;
	                    "description": string;
	                    "enum": string[];
	                };
	            };
	        };
	        "Container": {
	            "additionalProperties": boolean;
	            "type": string;
	            "description": string;
	            "allOf": {
	                "$ref": string;
	            }[];
	            "properties": {
	                "items": {
	                    "description": string;
	                    "$ref": string;
	                };
	                "selectAction": {
	                    "description": string;
	                    "$ref": string;
	                };
	                "style": {
	                    "type": string;
	                    "description": string;
	                    "enum": string[];
	                };
	                "type": {
	                    "type": string;
	                    "description": string;
	                    "enum": string[];
	                };
	            };
	            "required": string[];
	        };
	        "Fact": {
	            "additionalProperties": boolean;
	            "type": string;
	            "description": string;
	            "properties": {
	                "type": {
	                    "type": string;
	                    "enum": string[];
	                };
	                "title": {
	                    "type": string;
	                    "description": string;
	                };
	                "value": {
	                    "type": string;
	                    "description": string;
	                };
	            };
	            "required": string[];
	        };
	        "FactSet": {
	            "additionalProperties": boolean;
	            "type": string;
	            "description": string;
	            "allOf": {
	                "$ref": string;
	            }[];
	            "properties": {
	                "facts": {
	                    "type": string;
	                    "description": string;
	                    "items": {
	                        "$ref": string;
	                    };
	                };
	                "type": {
	                    "type": string;
	                    "description": string;
	                    "enum": string[];
	                };
	            };
	            "required": string[];
	        };
	        "HorizontalAlignment": {
	            "type": string;
	            "description": string;
	            "enum": string[];
	        };
	        "Image": {
	            "additionalProperties": boolean;
	            "type": string;
	            "description": string;
	            "allOf": {
	                "$ref": string;
	            }[];
	            "properties": {
	                "altText": {
	                    "type": string;
	                    "description": string;
	                };
	                "horizontalAlignment": {
	                    "$ref": string;
	                };
	                "selectAction": {
	                    "description": string;
	                    "$ref": string;
	                };
	                "size": {
	                    "type": string;
	                    "$ref": string;
	                };
	                "style": {
	                    "$ref": string;
	                };
	                "type": {
	                    "type": string;
	                    "description": string;
	                    "enum": string[];
	                };
	                "url": {
	                    "type": string;
	                    "description": string;
	                };
	            };
	            "required": string[];
	        };
	        "ImageSet": {
	            "additionalProperties": boolean;
	            "type": string;
	            "description": string;
	            "allOf": {
	                "$ref": string;
	            }[];
	            "properties": {
	                "images": {
	                    "type": string;
	                    "description": string;
	                    "items": {
	                        "$ref": string;
	                    };
	                };
	                "imageSize": {
	                    "$ref": string;
	                };
	                "type": {
	                    "type": string;
	                    "description": string;
	                    "enum": string[];
	                };
	            };
	            "required": string[];
	        };
	        "ImageSize": {
	            "type": string;
	            "description": string;
	            "default": string;
	            "enum": string[];
	        };
	        "ImageStyle": {
	            "type": string;
	            "description": string;
	            "enum": string[];
	        };
	        "Input.ChoiceSet": {
	            "additionalProperties": boolean;
	            "type": string;
	            "description": string;
	            "allOf": {
	                "$ref": string;
	            }[];
	            "properties": {
	                "choices": {
	                    "type": string;
	                    "description": string;
	                    "items": {
	                        "$ref": string;
	                    };
	                };
	                "id": {
	                    "type": string;
	                    "description": string;
	                };
	                "isMultiSelect": {
	                    "type": string;
	                    "description": string;
	                    "default": boolean;
	                };
	                "style": {
	                    "$ref": string;
	                };
	                "type": {
	                    "description": string;
	                    "enum": string[];
	                    "type": string;
	                };
	                "value": {
	                    "type": string;
	                    "description": string;
	                };
	            };
	            "required": string[];
	        };
	        "Input.Date": {
	            "additionalProperties": boolean;
	            "type": string;
	            "description": string;
	            "allOf": {
	                "$ref": string;
	            }[];
	            "properties": {
	                "id": {
	                    "type": string;
	                    "description": string;
	                };
	                "max": {
	                    "type": string;
	                    "description": string;
	                };
	                "min": {
	                    "type": string;
	                    "description": string;
	                };
	                "placeholder": {
	                    "type": string;
	                    "description": string;
	                };
	                "type": {
	                    "type": string;
	                    "description": string;
	                    "enum": string[];
	                };
	                "value": {
	                    "type": string;
	                    "description": string;
	                };
	            };
	            "required": string[];
	        };
	        "Input.Number": {
	            "additionalProperties": boolean;
	            "type": string;
	            "description": string;
	            "allOf": {
	                "$ref": string;
	            }[];
	            "properties": {
	                "id": {
	                    "type": string;
	                    "description": string;
	                };
	                "max": {
	                    "type": string;
	                    "description": string;
	                };
	                "min": {
	                    "type": string;
	                    "description": string;
	                };
	                "placeholder": {
	                    "type": string;
	                    "description": string;
	                };
	                "type": {
	                    "type": string;
	                    "description": string;
	                    "enum": string[];
	                };
	                "value": {
	                    "type": string;
	                    "description": string;
	                };
	            };
	            "required": string[];
	        };
	        "Input.Text": {
	            "additionalProperties": boolean;
	            "type": string;
	            "description": string;
	            "allOf": {
	                "$ref": string;
	            }[];
	            "properties": {
	                "id": {
	                    "type": string;
	                    "description": string;
	                };
	                "isMultiline": {
	                    "type": string;
	                    "description": string;
	                };
	                "maxLength": {
	                    "type": string;
	                    "description": string;
	                };
	                "placeholder": {
	                    "type": string;
	                    "description": string;
	                };
	                "style": {
	                    "$ref": string;
	                };
	                "type": {
	                    "type": string;
	                    "description": string;
	                    "enum": string[];
	                };
	                "value": {
	                    "type": string;
	                    "description": string;
	                };
	            };
	            "required": string[];
	        };
	        "Input.Time": {
	            "additionalProperties": boolean;
	            "type": string;
	            "description": string;
	            "allOf": {
	                "$ref": string;
	            }[];
	            "properties": {
	                "id": {
	                    "type": string;
	                    "description": string;
	                };
	                "max": {
	                    "type": string;
	                    "description": string;
	                };
	                "min": {
	                    "type": string;
	                    "description": string;
	                };
	                "placeholder": {
	                    "type": string;
	                    "description": string;
	                };
	                "type": {
	                    "type": string;
	                    "description": string;
	                    "enum": string[];
	                };
	                "value": {
	                    "type": string;
	                    "description": string;
	                };
	            };
	            "required": string[];
	        };
	        "Input.Toggle": {
	            "additionalProperties": boolean;
	            "type": string;
	            "description": string;
	            "allOf": {
	                "$ref": string;
	            }[];
	            "properties": {
	                "id": {
	                    "type": string;
	                    "description": string;
	                };
	                "title": {
	                    "type": string;
	                    "description": string;
	                };
	                "type": {
	                    "type": string;
	                    "description": string;
	                    "enum": string[];
	                };
	                "value": {
	                    "type": string;
	                    "description": string;
	                };
	                "valueOff": {
	                    "type": string;
	                    "description": string;
	                };
	                "valueOn": {
	                    "type": string;
	                    "description": string;
	                };
	            };
	            "required": string[];
	        };
	        "TextBlock": {
	            "additionalProperties": boolean;
	            "type": string;
	            "description": string;
	            "allOf": {
	                "$ref": string;
	            }[];
	            "properties": {
	                "color": {
	                    "type": string;
	                    "description": string;
	                    "enum": string[];
	                };
	                "horizontalAlignment": {
	                    "$ref": string;
	                };
	                "isSubtle": {
	                    "type": string;
	                    "description": string;
	                };
	                "maxLines": {
	                    "type": string;
	                    "description": string;
	                };
	                "size": {
	                    "type": string;
	                    "description": string;
	                    "enum": string[];
	                };
	                "text": {
	                    "type": string;
	                    "description": string;
	                };
	                "type": {
	                    "type": string;
	                    "description": string;
	                    "enum": string[];
	                };
	                "weight": {
	                    "type": string;
	                    "description": string;
	                    "enum": string[];
	                };
	                "wrap": {
	                    "type": string;
	                    "description": string;
	                };
	            };
	            "required": string[];
	        };
	        "SeparatorStyle": {
	            "type": string;
	            "description": string;
	            "properties": {
	                "thickness": {
	                    "type": string;
	                    "description": string;
	                    "enum": string[];
	                };
	                "color": {
	                    "type": string;
	                    "description": string;
	                    "enum": string[];
	                };
	            };
	        };
	        "SpacingStyle": {
	            "type": string;
	            "description": string;
	            "enum": string[];
	        };
	        "TextInputStyle": {
	            "type": string;
	            "description": string;
	            "enum": string[];
	        };
	    };
	};

}
declare module 'adaptivecards-designer/fullscreen-handler' {
	export class FullScreenHandler {
	    private fullScrerenChanged;
	    onFullScreenChanged: (isFullScreen: boolean) => void;
	    constructor();
	    enterFullScreen(): void;
	    exitFullScreen(): void;
	    toggleFullScreen(): void;
	    readonly isFullScreen: boolean;
	}

}
declare module 'adaptivecards-designer/toolbar' {
	export enum ToolbarElementAlignment {
	    Left = 0,
	    Right = 1
	}
	export abstract class ToolbarElement {
	    private _renderedElement;
	    protected abstract internalRender(): HTMLElement;
	    protected internalUpdateLayout(): void;
	    readonly id: string;
	    isVisible: boolean;
	    separator: boolean;
	    label: string;
	    alignment: ToolbarElementAlignment;
	    constructor(id: string);
	    updateLayout(): void;
	    render(): HTMLElement;
	    readonly renderedElement: HTMLElement;
	}
	export class ToolbarButton extends ToolbarElement {
	    private _caption;
	    private _displayCaption;
	    private _iconClass;
	    private _toolTip;
	    private _isEnabled;
	    private _allowToggle;
	    private _isToggled;
	    protected clicked(): void;
	    protected internalUpdateLayout(): void;
	    protected internalRender(): HTMLElement;
	    onClick: (sender: ToolbarButton) => void;
	    constructor(id: string, caption: string, iconClass: string, onClick?: (sender: ToolbarButton) => void);
	    allowToggle: boolean;
	    isToggled: boolean;
	    caption: string;
	    displayCaption: boolean;
	    iconClass: string;
	    toolTip: string;
	    isEnabled: boolean;
	}
	export interface IChoicePickerItem {
	    name: string;
	    value: string;
	}
	export class ToolbarChoicePicker extends ToolbarElement {
	    private _dropDown;
	    protected internalRender(): HTMLElement;
	    onChanged: (sender: ToolbarChoicePicker) => void;
	    label: string;
	    choices: Array<IChoicePickerItem>;
	    width?: number;
	    readonly value: string;
	    selectedIndex: number;
	}
	export class Toolbar {
	    private _elements;
	    private _attachedTo;
	    private createSeparatorElement;
	    private renderElementsInto;
	    attachTo(element: HTMLElement): void;
	    addElement(element: ToolbarElement): void;
	    getElementById(elementId: string): ToolbarElement;
	    insertElementAfter(element: ToolbarElement, afterElementId: string): void;
	    insertElementBefore(element: ToolbarElement, beforeElementId: string): void;
	}

}
declare module 'adaptivecards-designer/data' {
	export enum ValueKind {
	    String = 0,
	    Boolean = 1,
	    Number = 2
	}
	export abstract class DataType {
	    readonly owner: FieldDefinition;
	    static create(parent: FieldDefinition, value: any): DataType;
	    constructor(owner: FieldDefinition);
	    getChildFields(): FieldDefinition[];
	    qualifyFieldName(fieldName: string, fieldIsLeaf: boolean): string;
	    abstract readonly typeName: string;
	    readonly isCollection: boolean;
	}
	export class ValueData extends DataType {
	    readonly owner: FieldDefinition;
	    readonly valueKind: ValueKind;
	    constructor(owner: FieldDefinition, valueKind: ValueKind);
	    readonly typeName: string;
	}
	export class ArrayData extends DataType {
	    readonly owner: FieldDefinition;
	    static create(parent: FieldDefinition, input: Object): ArrayData;
	    dataType: DataType;
	    constructor(owner: FieldDefinition);
	    getChildFields(): FieldDefinition[];
	    qualifyFieldName(fieldName: string, fieldIsLeaf: boolean): string;
	    readonly isCollection: boolean;
	    readonly typeName: string;
	}
	export class ObjectData extends DataType {
	    readonly owner: FieldDefinition;
	    static create(parent: FieldDefinition, input: Object): ObjectData;
	    readonly fields: FieldDefinition[];
	    constructor(owner: FieldDefinition);
	    getChildFields(): FieldDefinition[];
	    readonly typeName: string;
	}
	export class FieldDefinition {
	    readonly parent: FieldDefinition;
	    static create(input: any): FieldDefinition;
	    name: string;
	    displayName: string;
	    dataType: DataType;
	    constructor(parent: FieldDefinition);
	    getPath(asLeaf?: boolean): string;
	    qualifiedName(asLeaf: boolean): string;
	    readonly children: FieldDefinition[];
	    readonly isCollection: boolean;
	    readonly typeName: string;
	}

}
declare module 'adaptivecards-designer/tool-palette' {
	import * as DesignerSurface from 'adaptivecards-designer/card-designer-surface';
	import * as DesignerPeers from 'adaptivecards-designer/designer-peers';
	import * as Adaptive from "adaptivecards";
	import { DraggableElement } from 'adaptivecards-designer/draggable-element';
	import { FieldDefinition } from 'adaptivecards-designer/data';
	export abstract class BasePaletteItem extends DraggableElement {
	    protected abstract getText(): string;
	    protected abstract getIconClass(): string;
	    protected internalRender(): HTMLElement;
	    renderDragVisual(): HTMLElement;
	    abstract createPeer(designer: DesignerSurface.CardDesignerSurface): DesignerPeers.CardElementPeer;
	}
	export class ElementPaletteItem extends BasePaletteItem {
	    protected getText(): string;
	    protected getIconClass(): string;
	    readonly typeRegistration: Adaptive.ITypeRegistration<Adaptive.CardElement>;
	    readonly peerRegistration: DesignerPeers.DesignerPeerRegistrationBase;
	    constructor(typeRegistration: Adaptive.ITypeRegistration<Adaptive.CardElement>, peerRegistration: DesignerPeers.DesignerPeerRegistrationBase);
	    createPeer(designer: DesignerSurface.CardDesignerSurface): DesignerPeers.CardElementPeer;
	}
	export class DataPaletteItem extends BasePaletteItem {
	    readonly field: FieldDefinition;
	    protected getText(): string;
	    protected getIconClass(): string;
	    constructor(field: FieldDefinition);
	    createPeer(designer: DesignerSurface.CardDesignerSurface): DesignerPeers.CardElementPeer;
	}
	export abstract class CustomPaletteItem extends BasePaletteItem {
	    readonly category: string;
	    protected getIconClass(): string;
	    constructor(category: string);
	}
	export class SnippetPaletteItem extends CustomPaletteItem {
	    protected getText(): string;
	    readonly name: string;
	    snippet: object;
	    constructor(category: string, name: string);
	    createPeer(designer: DesignerSurface.CardDesignerSurface): DesignerPeers.CardElementPeer;
	}

}
declare module 'adaptivecards-designer/splitter' {
	export class Splitter {
	    private _isVertical;
	    private _isAttachedAfter;
	    private _sizedELement;
	    private _isPointerDown;
	    private _lastClickedOffset;
	    private resizeEnded;
	    private pointerDown;
	    private pointerMove;
	    private pointerUp;
	    onResizeEnded: (sender: Splitter) => void;
	    onResized: (sender: Splitter) => void;
	    readonly attachedTo: HTMLElement;
	    minimum: number;
	    constructor(attachedTo: HTMLElement, sizedElement: HTMLElement, isVertical?: boolean, isAttachedAfter?: boolean, minimumSize?: number);
	}

}
declare module 'adaptivecards-designer/settings-manager' {
	export interface ILoadSettingResult<T> {
	    succeeded: boolean;
	    value?: T;
	}
	export class SettingsManager {
	    private static _isLocalStorageAvailable;
	    private static determineIfStorageIsAvailable;
	    static trySaveSetting(name: string, value: string): void;
	    static tryLoadStringSetting(name: string): ILoadSettingResult<string>;
	    static tryLoadNumberSetting(name: string): ILoadSettingResult<number>;
	    static tryLoadBooleanSetting(name: string, defaultValue: boolean): ILoadSettingResult<boolean>;
	    static readonly isLocalStorageAvailable: boolean;
	}

}
declare module 'adaptivecards-designer/tool-box' {
	export interface IToolboxCommand {
	    title: string;
	    iconClass: string;
	    execute: (sender: IToolboxCommand) => void;
	}
	export enum ToolboxOrientation {
	    Horizontal = 0,
	    Vertical = 1
	}
	export class Toolbox {
	    private _renderedElement;
	    private _headerRootElement;
	    private _headerIconElement;
	    private _expandCollapseButtonElement;
	    private _customCommandsHost;
	    private _contentHost;
	    private _isExpanded;
	    private _content;
	    private _stretch;
	    private _orientation;
	    private _isRestoring;
	    private _collapsedTabContainer;
	    private getDimensionSettingName;
	    private updateContent;
	    private toggled;
	    onToggled: (sender: Toolbox) => void;
	    readonly id: string;
	    readonly title: string;
	    commands: Array<IToolboxCommand>;
	    constructor(id: string, title: string);
	    render(orientation: ToolboxOrientation, collapsedTabContainer: HTMLElement): void;
	    collapse(): void;
	    expand(): void;
	    toggle(): void;
	    getHeaderBoundingRect(): ClientRect;
	    saveState(): void;
	    restoreState(): void;
	    readonly orientation: ToolboxOrientation;
	    readonly renderedElement: HTMLElement;
	    content: HTMLElement;
	    readonly isExpanded: boolean;
	    stretch: boolean;
	}

}
declare module 'adaptivecards-designer/side-panel' {
	import { Toolbox } from 'adaptivecards-designer/tool-box';
	export enum SidePanelAlignment {
	    Top = 0,
	    Right = 1,
	    Bottom = 2,
	    Left = 3
	}
	export class SidePanel {
	    private _attachedTo;
	    private _alignment;
	    private _collapsedTabContainer;
	    private _contentHost;
	    private _toolboxes;
	    private _isRestoring;
	    private updateLayout;
	    private computeToolboxSize;
	    private resized;
	    private toolboxResized;
	    private toolboxExpandedOrCollapsed;
	    private getDimensionSettingName;
	    private readonly isVertical;
	    onResized: (sender: SidePanel) => void;
	    onToolboxResized: (sender: SidePanel, toolbox: Toolbox) => void;
	    onToolboxExpandedOrCollapsed: (sender: SidePanel, toolbox: Toolbox) => void;
	    readonly id: any;
	    size?: number;
	    isResizable: boolean;
	    addToolbox(toolbox: Toolbox): void;
	    attachTo(attachTo: HTMLElement): void;
	    constructor(id: string, alignment: SidePanelAlignment, collapsedTabContainer: HTMLElement);
	    saveState(): void;
	    restoreState(): void;
	    readonly contentHost: HTMLElement;
	}

}
declare module 'adaptivecards-designer/data-treeitem' {
	import { BaseTreeItem } from 'adaptivecards-designer/base-tree-item';
	import * as Data from 'adaptivecards-designer/data';
	export class DataTreeItem extends BaseTreeItem {
	    private _children;
	    private buildChildList;
	    protected getLabelText(): string;
	    protected getAdditionalText(): string;
	    protected getAdditionalTextClass(): string;
	    readonly field: Data.FieldDefinition;
	    constructor(field: Data.FieldDefinition);
	    isDraggable(): boolean;
	    getChildCount(): number;
	    getChildAt(index: number): DataTreeItem;
	}

}
declare module 'adaptivecards-designer/card-designer' {
	import * as Adaptive from "adaptivecards";
	import * as Designer from 'adaptivecards-designer/card-designer-surface';
	import { HostContainer } from 'adaptivecards-designer/containers/host-container';
	import { Toolbar } from 'adaptivecards-designer/toolbar';
	import { CustomPaletteItem } from 'adaptivecards-designer/tool-palette';
	import { Toolbox } from 'adaptivecards-designer/tool-box';
	import { FieldDefinition } from 'adaptivecards-designer/data';
	import * as Shared from 'adaptivecards-designer/shared';
	export class CardDesigner {
	    private static internalProcessMarkdown;
	    static onProcessMarkdown: (text: string, result: Adaptive.IMarkdownProcessingResult) => void;
	    private static MAX_UNDO_STACK_SIZE;
	    private _isAttached;
	    private _cardEditor;
	    private _sampleDataEditor;
	    private _hostContainers;
	    private _isMonacoEditorLoaded;
	    private _designerSurface;
	    private _designerHostElement;
	    private _draggedPaletteItem;
	    private _draggedElement;
	    private _currentMousePosition;
	    private _card;
	    private _activeHostContainer;
	    private _undoStack;
	    private _undoStackIndex;
	    private _toolPaletteToolbox;
	    private _propertySheetToolbox;
	    private _treeViewToolbox;
	    private _jsonEditorsPanel;
	    private _cardEditorToolbox;
	    private _sampleDataEditorToolbox;
	    private _dataToolbox;
	    private _assetPath;
	    private _dataStructure;
	    private _sampleData;
	    private _customPeletteItems;
	    private togglePreview;
	    private buildTreeView;
	    private setupDataTreeItemEvents;
	    private buildDataExplorer;
	    private buildPropertySheet;
	    private addPaletteItem;
	    private buildPalette;
	    private endDrag;
	    private renderErrorPaneElement;
	    private recreateDesignerSurface;
	    private activeHostContainerChanged;
	    private updateToolboxLayout;
	    updateJsonEditorsLayout(): void;
	    private updateFullLayout;
	    private jsonUpdateTimer;
	    private cardUpdateTimer;
	    private updateLayoutTimer;
	    private preventCardUpdate;
	    private cardPayloadChanged;
	    private _cardEditorUpdateCounter;
	    private beginCardEditorUpdate;
	    private endCardEditorUpdate;
	    private setCardPayload;
	    private setSampleDataPayload;
	    private updateJsonFromCard;
	    private scheduleUpdateJsonFromCard;
	    private preventJsonUpdate;
	    private getCurrentCardEditorPayload;
	    private getCurrentSampleDataEditorPayload;
	    private updateCardFromJson;
	    private scheduleUpdateCardFromJson;
	    private scheduleLayoutUpdate;
	    private _fullScreenHandler;
	    private _fullScreenButton;
	    private _hostContainerChoicePicker;
	    private _versionChoicePicker;
	    private _undoButton;
	    private _redoButton;
	    private _newCardButton;
	    private _copyJSONButton;
	    private _togglePreviewButton;
	    private prepareToolbar;
	    private onResize;
	    private updateSampleData;
	    monacoModuleLoaded(monaco?: any): void;
	    private updateToolbar;
	    private addToUndoStack;
	    private handlePointerUp;
	    private handlePointerMove;
	    readonly toolbar: Toolbar;
	    sampleCatalogueUrl: string;
	    constructor(hostContainers?: Array<HostContainer>);
	    attachTo(root: HTMLElement): void;
	    undo(): void;
	    redo(): void;
	    newCard(): void;
	    setCard(payload: object): void;
	    getCard(): object;
	    onCardPayloadChanged: (designer: CardDesigner) => void;
	    onActiveHostContainerChanged: (designer: CardDesigner) => void;
	    readonly currentTargetVersion: Shared.TargetVersion;
	    dataStructure: FieldDefinition;
	    sampleData: any;
	    activeHostContainer: HostContainer;
	    readonly canUndo: boolean;
	    readonly canRedo: boolean;
	    card: Adaptive.AdaptiveCard;
	    readonly designerSurface: Designer.CardDesignerSurface;
	    readonly treeViewToolbox: Toolbox;
	    readonly propertySheetToolbox: Toolbox;
	    readonly jsonEditorToolbox: Toolbox;
	    readonly toolPaletteToolbox: Toolbox;
	    readonly dataToolbox: Toolbox;
	    assetPath: string;
	    customPaletteItems: CustomPaletteItem[];
	}
	export module CardDesigner {
	    class ToolbarCommands {
	        static FullScreen: string;
	        static OpenPayload: string;
	        static HostAppPicker: string;
	        static VersionPicker: string;
	        static Undo: string;
	        static Redo: string;
	        static NewCard: string;
	        static CopyJSON: string;
	        static TogglePreview: string;
	    }
	}

}
declare module 'adaptivecards-designer/adaptivecards-designer-standalone' {
	export * from 'adaptivecards-designer/strings';
	export * from 'adaptivecards-designer/shared';
	export * from 'adaptivecards-designer/containers/host-container';
	export * from 'adaptivecards-designer/containers/default/default-container';
	export * from 'adaptivecards-designer/card-designer-surface';
	export * from 'adaptivecards-designer/card-designer';
	export * from 'adaptivecards-designer/constants';
	export * from 'adaptivecards-designer/draggable-element';
	export * from 'adaptivecards-designer/designer-peers';
	export * from 'adaptivecards-designer/peer-command';
	export * from 'adaptivecards-designer/miscellaneous';
	export * from 'adaptivecards-designer/settings-manager';
	export * from 'adaptivecards-designer/side-panel';
	export * from 'adaptivecards-designer/tool-box';
	export * from 'adaptivecards-designer/toolbar';
	export * from 'adaptivecards-designer/tool-palette';
	export * from 'adaptivecards-designer/splitter';
	export * from 'adaptivecards-designer/base-tree-item';
	export * from 'adaptivecards-designer/designer-peer-treeitem';
	export * from 'adaptivecards-designer/data';
	export * from 'adaptivecards-designer/catalogue';
	export * from 'adaptivecards-designer/containers/host-container';
	export * from 'adaptivecards-designer/containers/default/default-container';

}
declare module 'adaptivecards-designer/adaptivecards-designer' {
	import * as containers from 'adaptivecards-designer/containers';
	export * from 'adaptivecards-designer/adaptivecards-designer-standalone';
	export * from 'adaptivecards-designer/containers/index';
	export const defaultMicrosoftHosts: containers.HostContainer[];

}
