{"version":3,"sources":["webpack://ACData/webpack/universalModuleDefinition","webpack://ACData/webpack/bootstrap","webpack://ACData/./src/expression-parser.ts","webpack://ACData/./src/shared.ts","webpack://ACData/./src/adaptivecards-templating.ts","webpack://ACData/./src/template-engine.ts"],"names":["root","factory","exports","module","define","amd","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","orderedOperators","literals","Tokenizer","init","rules","push","tokenType","undefined","regEx","parse","expression","result","length","subExpression","substring","matchFound","_i","_a","rule","matches","exec","Error","type","originalPosition","ensureValueType","FunctionCollection","_functions","indexOf","findIndex","f","register","callback","index","unregister","splice","find","EvaluationContext","_stateStack","_builtInFunctions","count","substr","input","JSON","toString","radix","parseInt","parseFloat","condition","ifTrue","ifFalse","toUpperCase","toLowerCase","format","inputAsNumber","Date","date","effectiveFormat","toLocaleDateString","day","weekday","month","year","toLocaleTimeString","hour","minute","Math","round","ceil","floor","registerFunction","unregisterFunction","getFunction","isReservedField","_reservedFields","saveState","$data","$index","restoreLastState","savedContext","pop","$root","EvaluationNode","ExpressionNode","_super","_this","apply","arguments","nodes","allowNull","__extends","evaluate","context","nodesCopy","slice","operatorPriorityGroups_1","priorityGroup","node","OperatorNode","operator","left","right","LiteralNode","IdentifierNode","identifier","IndexerNode","FunctionCallNode","functionName","parameters","evaluatedParams","param","PathNode","parts","part","currentDataContext","partValue","e","ExpressionParser","tokens","_index","_tokens","unexpectedToken","current","unexpectedEoe","moveNext","parseToken","expectedTokenTypes","eoe","currentToken","parseOptionalToken","parseFunctionCall","firstParameter","parseExpression","moreParameters","parameter","parseIdentifier","parseIndexer","parsePath","expectedNextTokenTypes","concat","parseBinding","expressionString","parser","Binding","GlobalSettings","undefinedExpressionValueSubstitutionString","__export","expression_parser_1","Shared","TemplatizedString","_parts","_shouldDropOwner","expressionFound","start","loop","end","bindngExpression","evalExpression","bindingExpression","internalEvaluate","evaluatedPart","Template","payload","preparedPayload","prepare","Array","isArray","node_1","item","keys_1","keys","expandSingleObject","keys_2","_context","internalExpand","itemArray","node_2","expandedItem","shouldDropOwner","dropObject","when","whenValue","dataContext","expandedObject","expand"],"mappings":"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","file":"adaptivecards-templating.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ACData\"] = factory();\n\telse\n\t\troot[\"ACData\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\ntype TokenType =\r\n    \"{\" |\r\n    \"?#\" |\r\n    \"}\" |\r\n    \"[\" |\r\n    \"]\" |\r\n    \"(\" |\r\n    \")\" |\r\n    \"identifier\" |\r\n    \".\" |\r\n    \",\" |\r\n    \"+\" |\r\n    \"-\" |\r\n    \"*\" |\r\n    \"/\" |\r\n    \"==\" |\r\n    \"!=\" |\r\n    \"<\" |\r\n    \"<=\" |\r\n    \">\" |\r\n    \">=\" |\r\n    \"string\" |\r\n    \"number\" |\r\n    \"boolean\";\r\n\r\nconst orderedOperators: Array<TokenType> = [\r\n    \"/\",\r\n    \"*\",\r\n    \"-\",\r\n    \"+\",\r\n    \"==\",\r\n    \"!=\",\r\n    \"<\",\r\n    \"<=\",\r\n    \">\",\r\n    \">=\"\r\n];\r\n\r\nconst literals: Array<TokenType> = [\r\n    \"identifier\",\r\n    \"string\",\r\n    \"number\",\r\n    \"boolean\"\r\n];\r\n\r\ninterface TokenizerRule {\r\n    tokenType: TokenType;\r\n    regEx: RegExp;\r\n}\r\n\r\ninterface Token {\r\n    type: TokenType;\r\n    value: string;\r\n    originalPosition: number;\r\n}\r\n\r\nclass Tokenizer {\r\n    static rules: Array<TokenizerRule> = [];\r\n\r\n    static init() {\r\n        Tokenizer.rules.push(\r\n            { tokenType: undefined, regEx: /^\\s/ },\r\n            { tokenType: \"{\", regEx: /^{/ },\r\n            { tokenType: \"?#\", regEx: /^\\?#/ },\r\n            { tokenType: \"}\", regEx: /^}/ },\r\n            { tokenType: \"[\", regEx: /^\\[/ },\r\n            { tokenType: \"]\", regEx: /^\\]/ },\r\n            { tokenType: \"(\", regEx: /^\\(/ },\r\n            { tokenType: \")\", regEx: /^\\)/ },\r\n            { tokenType: \"boolean\", regEx: /^true|^false/ },\r\n            { tokenType: \"identifier\", regEx: /^[$a-z_]+/i },\r\n            { tokenType: \".\", regEx: /^\\./ },\r\n            { tokenType: \",\", regEx: /^,/ },\r\n            { tokenType: \"+\", regEx: /^\\+/ },\r\n            { tokenType: \"-\", regEx: /^-/ },\r\n            { tokenType: \"*\", regEx: /^\\*/ },\r\n            { tokenType: \"/\", regEx: /^\\// },\r\n            { tokenType: \"==\", regEx: /^==/ },\r\n            { tokenType: \"!=\", regEx: /^!=/ },\r\n            { tokenType: \"<=\", regEx: /^<=/ },\r\n            { tokenType: \"<\", regEx: /^</ },\r\n            { tokenType: \">=\", regEx: /^>=/ },\r\n            { tokenType: \">\", regEx: /^>/ },\r\n            { tokenType: \"string\", regEx: /^\"([^\"]*)\"/ },\r\n            { tokenType: \"string\", regEx: /^'([^']*)'/ },\r\n            { tokenType: \"number\", regEx: /^\\d*\\.?\\d+/ }\r\n        )\r\n    }\r\n\r\n    static parse(expression: string): Token[] {\r\n        let result: Token[] = [];\r\n        let i = 0;\r\n\r\n        while (i < expression.length) {\r\n            let subExpression = expression.substring(i);\r\n            let matchFound = false;\r\n\r\n            for (let rule of Tokenizer.rules) {\r\n                let matches = rule.regEx.exec(subExpression);\r\n\r\n                if (matches) {\r\n                    if (matches.length > 2) {\r\n                        throw new Error(\"A tokenizer rule matched more than one group.\");\r\n                    }\r\n\r\n                    if (rule.tokenType !== undefined) {\r\n                        result.push(\r\n                            {\r\n                                type: rule.tokenType,\r\n                                value: matches[matches.length === 1 ? 0 : 1],\r\n                                originalPosition: i\r\n                            }\r\n                        )\r\n                    }\r\n\r\n                    i += matches[0].length;\r\n\r\n                    matchFound = true;\r\n\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (!matchFound) {\r\n                throw new Error(\"Unexpected character \" + subExpression[0] + \" at position \" + i);\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\nTokenizer.init();\r\n\r\ntype LiteralValue = string | number | boolean;\r\n\r\nfunction ensureValueType(value: any): LiteralValue {\r\n    if (typeof value === \"number\" || typeof value === \"string\" || typeof value === \"boolean\") {\r\n        return value;\r\n    }\r\n\r\n    throw new Error(\"Invalid value type: \" + typeof value);\r\n}\r\n\r\ntype FunctionCallback = (...params: any[]) => any;\r\n\r\ninterface FunctionDefinition {\r\n    name: string;\r\n    callback: FunctionCallback;\r\n}\r\n\r\nclass FunctionCollection {\r\n    private _functions: FunctionDefinition[] = [];\r\n\r\n    indexOf(name: string): number {\r\n        return this._functions.findIndex((f: FunctionDefinition) => { return f.name === name; });\r\n    }\r\n\r\n    register(name: string, callback: FunctionCallback) {\r\n        let index = this.indexOf(name);\r\n\r\n        if (index >= 0) {\r\n            this._functions[index].callback = callback;\r\n        }\r\n        else {\r\n            this._functions.push(\r\n                {\r\n                    name: name,\r\n                    callback: callback\r\n                }\r\n            );\r\n        }\r\n    }\r\n\r\n    unregister(name: string) {\r\n        let index = this.indexOf(name);\r\n\r\n        if (index >= 0) {\r\n            this._functions.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    find(name: string): FunctionDefinition | undefined {\r\n        let index = this.indexOf(name);\r\n\r\n        return index >= 0 ? this._functions[index] : undefined;\r\n    }\r\n}\r\n\r\ninterface EvaluationContextState {\r\n    $data: any;\r\n    $index: any;\r\n}\r\n\r\nexport class EvaluationContext {\r\n    private static readonly _reservedFields = [\"$data\", \"$root\", \"$index\"];\r\n    private static _builtInFunctions = new FunctionCollection();\r\n\r\n    static init() {\r\n        EvaluationContext._builtInFunctions.register(\r\n            \"substr\",\r\n            (s, index, count) => {\r\n                if (typeof s === \"string\" && typeof index === \"number\" && typeof count === \"number\") {\r\n                    return (s.substr(index, count));\r\n                }\r\n                else {\r\n                    return \"\";\r\n                }\r\n            }\r\n        );\r\n        EvaluationContext._builtInFunctions.register(\r\n            \"JSON.parse\",\r\n            (input) => {\r\n                return JSON.parse(input);\r\n            }\r\n        );\r\n        EvaluationContext._builtInFunctions.register(\r\n            \"toString\",\r\n            (input) => {\r\n                if (input.toString) {\r\n                    return input.toString();\r\n                }\r\n\r\n                return input;\r\n            }\r\n        );\r\n        EvaluationContext._builtInFunctions.register(\r\n            \"parseInt\",\r\n            (input, radix) => {\r\n                if (typeof input === \"string\" && (radix === undefined || typeof radix === \"number\")) {\r\n                    return parseInt(input, radix);\r\n                }\r\n                else {\r\n                    return input;\r\n                }\r\n            }\r\n        );\r\n        EvaluationContext._builtInFunctions.register(\r\n            \"parseFloat\",\r\n            (input) => {\r\n                return typeof input === \"string\" ? parseFloat(input) : input;\r\n            }\r\n        );\r\n        EvaluationContext._builtInFunctions.register(\r\n            \"if\",\r\n            (condition, ifTrue, ifFalse) => {\r\n                return condition ? ifTrue : ifFalse;\r\n            }\r\n        );\r\n        EvaluationContext._builtInFunctions.register(\r\n            \"toUpper\",\r\n            (input) => {\r\n                return typeof input === \"string\" ? input.toUpperCase() : input;\r\n            }\r\n        );\r\n        EvaluationContext._builtInFunctions.register(\r\n            \"toLower\",\r\n            (input) => {\r\n                return typeof input === \"string\" ? input.toLowerCase() : input;\r\n            }\r\n        );\r\n        EvaluationContext._builtInFunctions.register(\r\n            \"Date.format\",\r\n            (input, format) => {\r\n                const acceptedFormats = [ \"long\", \"short\", \"compact\" ];\r\n\r\n                let inputAsNumber: number;\r\n\r\n                if (typeof input === \"string\") {\r\n                    inputAsNumber = Date.parse(input);\r\n                }\r\n                else if (typeof input === \"number\") {\r\n                    inputAsNumber = input;\r\n                }\r\n                else {\r\n                    return input;\r\n                }\r\n\r\n                let date = new Date(inputAsNumber);\r\n\r\n                let effectiveFormat: string = \"compact\";\r\n\r\n                if (typeof format === \"string\") {\r\n                    effectiveFormat = format.toLowerCase();\r\n\r\n                    if (acceptedFormats.indexOf(effectiveFormat) < 0) {\r\n                        effectiveFormat = \"compact\";\r\n                    }\r\n                }\r\n\r\n                return effectiveFormat === \"compact\" ? date.toLocaleDateString() : date.toLocaleDateString(undefined, { day: \"numeric\", weekday: effectiveFormat, month: effectiveFormat, year: \"numeric\" });\r\n            }\r\n        );\r\n        EvaluationContext._builtInFunctions.register(\r\n            \"Time.format\",\r\n            (input) => {\r\n                let inputAsNumber: number;\r\n\r\n                if (typeof input === \"string\") {\r\n                    inputAsNumber = Date.parse(input);\r\n                }\r\n                else if (typeof input === \"number\") {\r\n                    inputAsNumber = input;\r\n                }\r\n                else {\r\n                    return input;\r\n                }\r\n\r\n                let date = new Date(inputAsNumber);\r\n\r\n                return date.toLocaleTimeString(undefined, { hour: 'numeric', minute: '2-digit' });\r\n            }\r\n        );\r\n        EvaluationContext._builtInFunctions.register(\r\n            \"round\",\r\n            (input) => {\r\n                return typeof input === \"number\" ? Math.round(input) : input;\r\n            }\r\n        );\r\n        EvaluationContext._builtInFunctions.register(\r\n            \"ceil\",\r\n            (input) => {\r\n                return typeof input === \"number\" ? Math.ceil(input) : input;\r\n            }\r\n        );\r\n        EvaluationContext._builtInFunctions.register(\r\n            \"floor\",\r\n            (input) => {\r\n                return typeof input === \"number\" ? Math.floor(input) : input;\r\n            }\r\n        );\r\n    }\r\n\r\n    private _functions = new FunctionCollection();\r\n    private _stateStack: EvaluationContextState[] = [];\r\n\r\n    $root: any;\r\n    $data: any;\r\n    $index: number;\r\n\r\n    registerFunction(name: string, callback: FunctionCallback) {\r\n        this._functions.register(name, callback);\r\n    }\r\n\r\n    unregisterFunction(name: string) {\r\n        this._functions.unregister(name);\r\n    }\r\n\r\n    getFunction(name: string): FunctionCallback {\r\n        let f = this._functions.find(name);\r\n\r\n        if (!f)  {\r\n            f = EvaluationContext._builtInFunctions.find(name);\r\n        }\r\n\r\n        return f ? f.callback : undefined;\r\n    }\r\n\r\n    isReservedField(name: string): boolean {\r\n        return EvaluationContext._reservedFields.indexOf(name) >= 0;\r\n    }\r\n\r\n    saveState() {\r\n        this._stateStack.push({ $data: this.$data, $index: this.$index });\r\n    }\r\n\r\n    restoreLastState() {\r\n        if (this._stateStack.length === 0) {\r\n            throw new Error(\"There is no evaluation context state to restore.\");\r\n        }\r\n\r\n        let savedContext = this._stateStack.pop();\r\n\r\n        this.$data = savedContext.$data;\r\n        this.$index = savedContext.$index;\r\n    }\r\n\r\n    get currentDataContext(): any {\r\n        return this.$data !== undefined ? this.$data : this.$root;\r\n    }\r\n}\r\n\r\nEvaluationContext.init();\r\n\r\nabstract class EvaluationNode {\r\n    abstract evaluate(context: EvaluationContext): LiteralValue;\r\n}\r\n\r\nclass ExpressionNode extends EvaluationNode {\r\n    nodes: Array<EvaluationNode> = [];\r\n    allowNull: boolean = true;\r\n\r\n    evaluate(context: EvaluationContext): any {\r\n        const operatorPriorityGroups = [\r\n            [\"/\", \"*\"],\r\n            [\"-\", \"+\"],\r\n            [\"==\", \"!=\", \"<\", \"<=\", \">\", \">=\"]\r\n        ];\r\n\r\n        let nodesCopy = this.nodes.slice();\r\n\r\n        for (let priorityGroup of operatorPriorityGroups) {\r\n            let i = 0;\r\n\r\n            while (i < nodesCopy.length) {\r\n                let node = nodesCopy[i];\r\n\r\n                if (node instanceof OperatorNode && priorityGroup.indexOf(node.operator) >= 0) {\r\n                    let left = ensureValueType(nodesCopy[i - 1].evaluate(context));\r\n                    let right = ensureValueType(nodesCopy[i + 1].evaluate(context));\r\n\r\n                    if (typeof left !== typeof right) {\r\n                        throw new Error(\"Incompatible operands \" + left + \" and \" + right + \" for operator \" + node.operator);\r\n                    }\r\n\r\n                    let result: LiteralValue;\r\n\r\n                    if (typeof left === \"number\" && typeof right === \"number\") {\r\n                        switch (node.operator) {\r\n                            case \"/\":\r\n                                result = left / right;\r\n                                break;\r\n                            case \"*\":\r\n                                result = left * right;\r\n                                break;\r\n                            case \"-\":\r\n                                result = left - right;\r\n                                break;\r\n                            case \"+\":\r\n                                result = left + right;\r\n                                break;\r\n                        }\r\n                    }\r\n\r\n                    if (typeof left === \"string\" && typeof right === \"string\") {\r\n                        switch (node.operator) {\r\n                            case \"+\":\r\n                                result = left + right;\r\n                                break;\r\n                        }\r\n                    }\r\n\r\n                    switch (node.operator) {\r\n                        case \"==\":\r\n                            result = left === right;\r\n                            break;\r\n                        case \"!=\":\r\n                            result = left !== right;\r\n                            break;\r\n                        case \"<\":\r\n                            result = left < right;\r\n                            break;\r\n                        case \"<=\":\r\n                            result = left <= right;\r\n                            break;\r\n                        case \">\":\r\n                            result = left > right;\r\n                            break;\r\n                        case \">=\":\r\n                            result = left >= right;\r\n                            break;\r\n                        default:\r\n                            // This should never happen\r\n                    }\r\n\r\n                    nodesCopy.splice(i - 1, 3, new LiteralNode(result));\r\n\r\n                    i--;\r\n                }\r\n\r\n                i++;\r\n            };\r\n        }\r\n\r\n        return nodesCopy[0].evaluate(context);\r\n    }\r\n}\r\n\r\nclass IdentifierNode extends EvaluationNode {\r\n    identifier: string;\r\n\r\n    evaluate(context: EvaluationContext): LiteralValue {\r\n        return this.identifier;\r\n    }\r\n}\r\n\r\nclass IndexerNode extends EvaluationNode {\r\n    index: ExpressionNode;\r\n\r\n    evaluate(context: EvaluationContext): LiteralValue {\r\n        return this.index.evaluate(context);\r\n    }\r\n}\r\n\r\nclass FunctionCallNode extends EvaluationNode {\r\n    functionName: string = null;\r\n    parameters: Array<ExpressionNode> = [];\r\n\r\n    evaluate(context: EvaluationContext): LiteralValue {\r\n        let callback = context.getFunction(this.functionName);\r\n\r\n        if (callback !== undefined) {\r\n            let evaluatedParams = [];\r\n\r\n            for (let param of this.parameters) {\r\n                evaluatedParams.push(param.evaluate(context));\r\n            }\r\n\r\n            return callback(...evaluatedParams);\r\n        }\r\n\r\n        throw new Error(\"Undefined function: \" + this.functionName);\r\n    }\r\n}\r\n\r\nclass LiteralNode extends EvaluationNode {\r\n    constructor(readonly value: LiteralValue) {\r\n        super();\r\n    }\r\n\r\n    evaluate(context: EvaluationContext): LiteralValue {\r\n        return this.value;\r\n    }\r\n}\r\n\r\nclass OperatorNode extends EvaluationNode {\r\n    constructor(readonly operator: TokenType) {\r\n        super();\r\n    }\r\n\r\n    evaluate(context: EvaluationContext): LiteralValue {\r\n        throw new Error(\"An operator cannot be evaluated on its own.\");\r\n    }\r\n}\r\n\r\ntype PathPart = ExpressionNode | IdentifierNode | IndexerNode | FunctionCallNode;\r\n\r\nclass PathNode extends EvaluationNode {\r\n    parts: PathPart[] = [];\r\n\r\n    evaluate(context: EvaluationContext): LiteralValue {\r\n        let result: any = undefined;\r\n        let index = 0;\r\n\r\n        while (index < this.parts.length) {\r\n            let part = this.parts[index];\r\n\r\n            try {\r\n                if (part instanceof IdentifierNode && index === 0) {\r\n                    switch (part.identifier) {\r\n                        case \"$root\":\r\n                            result = context.$root;\r\n            \r\n                            break;\r\n                        case \"$data\":\r\n                            result = context.currentDataContext;\r\n            \r\n                            break;\r\n                        case \"$index\":\r\n                            result = context.$index;\r\n            \r\n                            break;\r\n                        default:\r\n                            result = context.currentDataContext[part.identifier];\r\n            \r\n                            break;\r\n                    }            \r\n                }\r\n                else {\r\n                    let partValue = part.evaluate(context);\r\n\r\n                    if (index === 0) {\r\n                        result = partValue;\r\n                    }\r\n                    else {\r\n                        result = typeof partValue !== \"boolean\" ? result[partValue] : result[partValue.toString()];\r\n                    }\r\n                }\r\n            }\r\n            catch (e) {\r\n                return undefined;\r\n            }\r\n\r\n            index++;\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\nexport class ExpressionParser {\r\n    private _index: number = 0;\r\n    private _tokens: Token[];\r\n\r\n    private unexpectedToken() {\r\n        throw new Error(\"Unexpected token \" + this.current.value + \" at position \" + this.current.originalPosition + \".\");\r\n    }\r\n\r\n    private unexpectedEoe() {\r\n        throw new Error(\"Unexpected end of expression.\");\r\n    }\r\n\r\n    private moveNext() {\r\n        this._index++;\r\n    }\r\n\r\n    private parseToken(...expectedTokenTypes: TokenType[]): Token {\r\n        if (this.eoe) {\r\n            this.unexpectedEoe();\r\n        }\r\n\r\n        let currentToken = this.current;\r\n\r\n        if (expectedTokenTypes.indexOf(this.current.type) < 0) {\r\n            this.unexpectedToken();\r\n        }\r\n\r\n        this.moveNext();\r\n\r\n        return currentToken;\r\n    }\r\n\r\n    private parseOptionalToken(...expectedTokenTypes: TokenType[]): boolean {\r\n        if (this.eoe) {\r\n            this.unexpectedEoe();\r\n        }\r\n        else if (expectedTokenTypes.indexOf(this.current.type) < 0) {\r\n            return false;\r\n        }\r\n        else {\r\n            this.moveNext();\r\n\r\n            return true;\r\n        }\r\n    }\r\n\r\n    private parseFunctionCall(functionName: string): FunctionCallNode {\r\n        let result = new FunctionCallNode();\r\n        result.functionName = functionName;\r\n\r\n        this.parseToken(\"(\");\r\n\r\n        let firstParameter = this.parseExpression();\r\n        let moreParameters: boolean = false;\r\n\r\n        if (firstParameter) {\r\n            result.parameters.push(firstParameter);\r\n\r\n            do {\r\n                moreParameters = this.parseOptionalToken(\",\");\r\n\r\n                if (moreParameters) {\r\n                    let parameter = this.parseExpression();\r\n\r\n                    result.parameters.push(parameter);\r\n                }\r\n            } while (moreParameters);\r\n        }\r\n\r\n        this.parseToken(\")\");\r\n\r\n        return result;\r\n    }\r\n\r\n    private parseIdentifier(): IdentifierNode {\r\n        let result = new IdentifierNode();\r\n\r\n        result.identifier = this.current.value;\r\n\r\n        this.moveNext();\r\n\r\n        return result;\r\n    }\r\n\r\n    private parseIndexer(): IndexerNode {\r\n        let result = new IndexerNode();\r\n\r\n        this.parseToken(\"[\");\r\n\r\n        result.index = this.parseExpression();\r\n\r\n        this.parseToken(\"]\");\r\n\r\n        return result;\r\n    }\r\n\r\n    private parsePath(): PathNode {\r\n        let result = new PathNode();\r\n\r\n        let expectedNextTokenTypes: TokenType[] = [\"identifier\", \"(\"];\r\n\r\n        while (!this.eoe) {\r\n            if (expectedNextTokenTypes.indexOf(this.current.type) < 0) {\r\n                return result;\r\n            }\r\n\r\n            switch (this.current.type) {\r\n                case \"(\":\r\n                    if (result.parts.length === 0) {\r\n                        this.moveNext();\r\n    \r\n                        result.parts.push(this.parseExpression());\r\n    \r\n                        this.parseToken(\")\");\r\n                    }\r\n                    else {\r\n                        let functionName: string = \"\";\r\n\r\n                        for (let part of result.parts) {\r\n                            if (!(part instanceof IdentifierNode)) {\r\n                                this.unexpectedToken();\r\n                            }\r\n\r\n                            if (functionName !== \"\") {\r\n                                functionName += \".\";\r\n                            }\r\n\r\n                            functionName += (<IdentifierNode>part).identifier;\r\n                        }\r\n\r\n                        result.parts = [];\r\n\r\n                        result.parts.push(this.parseFunctionCall(functionName));\r\n                    }\r\n\r\n                    expectedNextTokenTypes = [\".\", \"[\"];\r\n\r\n                    break;\r\n                case \"[\":\r\n                    result.parts.push(this.parseIndexer());\r\n\r\n                    expectedNextTokenTypes = [\".\", \"(\", \"[\"];\r\n\r\n                    break;\r\n                case \"identifier\":\r\n                    result.parts.push(this.parseIdentifier());\r\n\r\n                    expectedNextTokenTypes = [\".\", \"(\", \"[\"];\r\n\r\n                    break;\r\n                case \".\":\r\n                    this.moveNext();\r\n\r\n                    expectedNextTokenTypes = [\"identifier\"];\r\n\r\n                    break;\r\n                default:\r\n                    expectedNextTokenTypes = [];\r\n\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n\r\n    private parseExpression(): ExpressionNode {\r\n        let result: ExpressionNode = new ExpressionNode();\r\n\r\n        let expectedNextTokenTypes: TokenType[] = literals.concat(\"(\", \"+\", \"-\");\r\n\r\n        while (!this.eoe) {\r\n            if (expectedNextTokenTypes.indexOf(this.current.type) < 0) {\r\n                if (result.nodes.length === 0) {\r\n                    this.unexpectedToken();\r\n                }\r\n\r\n                return result;\r\n            }\r\n\r\n            switch (this.current.type) {\r\n                case \"(\":\r\n                case \"identifier\":\r\n                    result.nodes.push(this.parsePath());\r\n\r\n                    expectedNextTokenTypes = orderedOperators;\r\n\r\n                    break;\r\n                case \"string\":\r\n                case \"number\":\r\n                case \"boolean\":\r\n                    if (this.current.type === \"string\") {\r\n                        result.nodes.push(new LiteralNode(this.current.value));\r\n                    }\r\n                    else if (this.current.type === \"number\") {\r\n                        result.nodes.push(new LiteralNode(parseFloat(this.current.value)));\r\n                    }\r\n                    else {\r\n                        result.nodes.push(new LiteralNode(this.current.value === \"true\"));\r\n                    }\r\n\r\n                    this.moveNext();\r\n\r\n                    expectedNextTokenTypes = orderedOperators;\r\n\r\n                    break;\r\n                case \"-\":\r\n                    if (result.nodes.length === 0) {\r\n                        result.nodes.push(new LiteralNode(-1));\r\n                        result.nodes.push(new OperatorNode(\"*\"));\r\n\r\n                        expectedNextTokenTypes = [\"identifier\", \"number\", \"(\"];\r\n                    }\r\n                    else {\r\n                        result.nodes.push(new OperatorNode(this.current.type));\r\n\r\n                        expectedNextTokenTypes = literals.concat(\"(\");\r\n                    }\r\n\r\n                    this.moveNext();\r\n\r\n                    break;\r\n                case \"+\":\r\n                    if (result.nodes.length === 0) {\r\n                        expectedNextTokenTypes = literals.concat(\"(\");\r\n                    }\r\n                    else {\r\n                        result.nodes.push(new OperatorNode(this.current.type));\r\n\r\n                        expectedNextTokenTypes = literals.concat(\"(\");\r\n                    }\r\n\r\n                    this.moveNext();\r\n\r\n                    break;\r\n                case \"*\":\r\n                case \"/\":\r\n                case \"==\":\r\n                case \"!=\":\r\n                case \"<\":\r\n                case \"<=\":\r\n                case \">\":\r\n                case \">=\":\r\n                    result.nodes.push(new OperatorNode(this.current.type));\r\n\r\n                    this.moveNext();\r\n\r\n                    expectedNextTokenTypes = literals.concat(\"(\");\r\n\r\n                    break;\r\n                default:\r\n                    expectedNextTokenTypes = [];\r\n\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n\r\n    private get eoe(): boolean {\r\n        return this._index >= this._tokens.length;\r\n    }\r\n\r\n    private get current(): Token {\r\n        return this._tokens[this._index];\r\n    }\r\n\r\n    static parseBinding(expressionString: string): Binding {\r\n        let parser = new ExpressionParser(Tokenizer.parse(expressionString));\r\n        parser.parseToken(\"{\");\r\n\r\n        let allowNull = !parser.parseOptionalToken(\"?#\");\r\n        let expression = parser.parseExpression();\r\n\r\n        parser.parseToken(\"}\");\r\n\r\n        return new Binding(expressionString, expression, allowNull);\r\n    }\r\n\r\n    constructor(tokens: Token[]) {\r\n        this._tokens = tokens;\r\n    }\r\n}\r\n\r\nexport class Binding {\r\n    constructor(readonly expressionString: string, private readonly expression: EvaluationNode, readonly allowNull: boolean = true) {}\r\n\r\n    evaluate(context: EvaluationContext): LiteralValue {\r\n        return this.expression.evaluate(context);\r\n    }\r\n}","// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\nexport class GlobalSettings {\r\n    static undefinedExpressionValueSubstitutionString?: string = undefined;\r\n}","// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\nexport * from \"./expression-parser\";\r\nexport * from \"./template-engine\";\r\nexport * from \"./shared\";","// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\nimport { Binding, ExpressionParser, EvaluationContext } from \"./expression-parser\";\r\nimport * as Shared from \"./shared\";\r\n\r\nclass TemplatizedString {\r\n    private _parts: Array<string | Binding> = [];\r\n\r\n    static parse(s: string): string | TemplatizedString {\r\n        let result = new TemplatizedString();\r\n        let i = 0;\r\n\r\n        do {\r\n            let expressionFound = false;\r\n            let start = i;\r\n            let loop;\r\n            \r\n            do {\r\n                loop = false;\r\n\r\n                start = s.indexOf(\"{\", start);\r\n\r\n                if (start >= 0) {\r\n                    if (start + 1 < s.length && s[start + 1] === \"{\") {\r\n                        start += 2;\r\n\r\n                        loop = true;\r\n                    }\r\n                }\r\n            } while (loop);\r\n\r\n            if (start >= 0) {\r\n                let end = s.indexOf(\"}\", start);\r\n\r\n                if (end >= 0) {\r\n                    expressionFound = true;\r\n\r\n                    if (start > i) {\r\n                        result._parts.push(s.substring(i, start));\r\n                    }\r\n\r\n                    let bindngExpression = s.substring(start, end + 1);\r\n                    let part: string | Binding;\r\n\r\n                    try {\r\n                        part = ExpressionParser.parseBinding(bindngExpression);\r\n                    }\r\n                    catch (e) {\r\n                        part = bindngExpression;\r\n                    }\r\n\r\n                    result._parts.push(part);\r\n\r\n                    i = end + 1;\r\n                }\r\n            }\r\n\r\n            if (!expressionFound) {\r\n                result._parts.push(s.substr(i));\r\n\r\n                break;\r\n            }\r\n        } while (i < s.length);\r\n\r\n        if (result._parts.length === 1 && typeof result._parts[0] === \"string\") {\r\n            return <string>result._parts[0];\r\n        }\r\n        else {\r\n            return result;\r\n        }\r\n    }\r\n\r\n    private _shouldDropOwner: boolean = false;\r\n\r\n    private evalExpression(bindingExpression: Binding, context: EvaluationContext): any {\r\n        let result = bindingExpression.evaluate(context);\r\n\r\n        if (result === undefined) {\r\n            this._shouldDropOwner = this._shouldDropOwner || !bindingExpression.allowNull;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    private internalEvaluate(context: EvaluationContext): any {\r\n        if (this._parts.length === 0) {\r\n            return undefined;\r\n        }\r\n        else if (this._parts.length === 1) {\r\n            // If the templatized string only has 1 part, we want it to evaluate\r\n            // to same the type as produced by the expression\r\n            if (typeof this._parts[0] === \"string\") {\r\n                return this._parts[0];\r\n            }\r\n            else {\r\n                return this.evalExpression(<Binding>this._parts[0], context);\r\n            }\r\n        }\r\n        else {\r\n            // If the templatized string has multiple parts, we want it to evaluate\r\n            // to a string. In that context, each part that evaluates to undefined\r\n            // gets replaced by the original expression by default or by a resource\r\n            // string provided by the application\r\n            let s = \"\";\r\n\r\n            for (let part of this._parts) {\r\n                if (typeof part === \"string\") {\r\n                    s += part;\r\n                }\r\n                else {\r\n                    let evaluatedPart = this.evalExpression(<Binding>part, context);\r\n\r\n                    if (evaluatedPart === undefined) {\r\n                        evaluatedPart = Shared.GlobalSettings.undefinedExpressionValueSubstitutionString ? Shared.GlobalSettings.undefinedExpressionValueSubstitutionString : (<Binding>part).expressionString;\r\n                    }\r\n\r\n                    s += evaluatedPart;\r\n                }\r\n            }\r\n\r\n            return s;\r\n        }\r\n    }\r\n\r\n    evaluate(context: EvaluationContext): any {\r\n        this._shouldDropOwner = false;\r\n\r\n        return this.internalEvaluate(context);\r\n    }\r\n\r\n    get shouldDropOwner(): boolean {\r\n        return this._shouldDropOwner;\r\n    }\r\n}\r\n\r\nexport class Template {\r\n    private static prepare(node: any): any {\r\n        if (typeof node === \"string\") {\r\n            return TemplatizedString.parse(node);\r\n        }\r\n        else if (typeof node === \"object\" && node !== null) {\r\n            if (Array.isArray(node)) {\r\n                let result: any[] = [];\r\n\r\n                for (let item of node) {\r\n                    result.push(Template.prepare(item));\r\n                }\r\n\r\n                return result;\r\n            }\r\n            else {\r\n                let keys = Object.keys(node);\r\n                let result = {};\r\n\r\n                for (let key of keys) {\r\n                    result[key] = Template.prepare(node[key]);\r\n                }\r\n\r\n                return result;\r\n            }\r\n        }\r\n        else {\r\n            return node;\r\n        }\r\n    }\r\n\r\n    private _context: EvaluationContext;\r\n\r\n    private expandSingleObject(node: object): any {\r\n        let result = {};\r\n        let keys = Object.keys(node);\r\n\r\n        for (let key of keys) {\r\n            if (!this._context.isReservedField(key)) {\r\n                let value = this.internalExpand(node[key]);\r\n\r\n                if (value !== undefined) {\r\n                    result[key] = value;\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    private internalExpand(node: any): any {\r\n        let result: any;\r\n\r\n        this._context.saveState();\r\n\r\n        if (Array.isArray(node)) {\r\n            let itemArray: any[] = [];\r\n\r\n            for (let item of node) {\r\n                let expandedItem = this.internalExpand(item);\r\n\r\n                if (expandedItem !== null) {\r\n                    if (Array.isArray(expandedItem)) {\r\n                        itemArray = itemArray.concat(expandedItem);\r\n                    }\r\n                    else {\r\n                        itemArray.push(expandedItem);\r\n                    }\r\n                }\r\n            }\r\n\r\n            result = itemArray;\r\n        }\r\n        else if (node instanceof TemplatizedString) {\r\n            result = node.evaluate(this._context);\r\n\r\n            if (node.shouldDropOwner) {\r\n                result = null;\r\n            }\r\n        }\r\n        else if (typeof node === \"object\" && node !== null) {\r\n            let dropObject = false;\r\n            let when = node[\"$when\"];\r\n\r\n            if (when instanceof TemplatizedString) {\r\n                let whenValue: any;\r\n                \r\n                try {\r\n                    whenValue = when.evaluate(this._context);\r\n\r\n                    // If $when doesn't evaluate to a boolean, consider it is false\r\n                    if (typeof whenValue !== \"boolean\") {\r\n                        whenValue = false;\r\n                    }\r\n                }\r\n                catch {\r\n                    // If we hit an exception, consider $when to be false\r\n                    whenValue = false;\r\n                }\r\n\r\n                dropObject = !whenValue;\r\n            }\r\n\r\n            if (!dropObject) {\r\n                let dataContext = node[\"$data\"];\r\n\r\n                if (dataContext !== undefined) {\r\n                    if (dataContext instanceof TemplatizedString) {\r\n                        dataContext = dataContext.evaluate(this._context);\r\n                    }\r\n\r\n                    if (Array.isArray(dataContext)) {\r\n                        result = [];\r\n\r\n                        for (let i = 0; i < dataContext.length; i++) {\r\n                            this._context.$data = dataContext[i];\r\n                            this._context.$index = i;\r\n\r\n                            let expandedObject = this.expandSingleObject(node);\r\n\r\n                            if (expandedObject !== null) {\r\n                                result.push(expandedObject);\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        this._context.$data = dataContext;\r\n\r\n                        result = this.expandSingleObject(node);\r\n                    }\r\n                }\r\n                else {\r\n                    result = this.expandSingleObject(node);\r\n                }\r\n            }\r\n            else {\r\n                result = null;\r\n            }\r\n        }\r\n        else {\r\n            result = node;\r\n        }\r\n\r\n        this._context.restoreLastState();\r\n\r\n        return result;\r\n    }\r\n\r\n    preparedPayload: any;\r\n\r\n    constructor(payload: any) {\r\n        this.preparedPayload = Template.prepare(payload);\r\n    }\r\n\r\n    expand(context: EvaluationContext): any {\r\n        this._context = context;\r\n\r\n        return this.internalExpand(this.preparedPayload);\r\n    }\r\n}"],"sourceRoot":""}